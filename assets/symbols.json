{
  "version": "1.0",
  "objects": [
    {
      "object": "cComponentManager",
      "fields": [
        {
          "field": "instance",
          "description": "Associative array storing component list.\n   Array indicies are the instance names.",
          "type": "cComponentManagerInst"
        },
        {
          "field": "printLevelStats",
          "description": "1 = print detailed information about data memory level configuration, 2 = print even more details (?)",
          "type": "numeric",
          "default": 0.0
        },
        {
          "field": "printFinalLevelStates",
          "description": "1 = print the state of all data memory levels at end of processing",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "profiling",
          "description": "1 = collect per component instance run-time stats and show summary at end of processing.",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "nThreads",
          "description": "number of threads to run (0=auto(=one thread per component), >0 = actual number of threads",
          "type": "numeric",
          "default": 1.0
        },
        {
          "field": "threadPriority",
          "description": "The default thread scheduling priority (multi-thread mode) or the priority of the single thread (single thread mode). 0 is normal priority (-15 is background/idle priority, +15 is time critical). This option is currently only supported on windows!",
          "type": "numeric",
          "default": 0.0
        },
        {
          "field": "execDebug",
          "description": "print summary of component run statistics to log for each tick",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "oldSingleIterationTickLoop",
          "description": "1 = run the old single iteration tick loop with a single EOI tick loop after the main tick loop. Use this for backwards compatibility for older configs with components such as fullinputMean.",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        }
      ]
    },
    {
      "object": "cDataMemoryLevel",
      "fields": [
        {
          "field": "name",
          "description": "The name of this data memory level, must be unique within one data memory instance.",
          "type": "string",
          "default": null
        },
        {
          "field": "type",
          "description": "The data type of the level [can be: 'float' or 'int'(eger) , currently only float is supported by the majority of processing components ]",
          "type": "string",
          "default": "float",
          "allowedValues": [
            "float",
            "int",
            "integer"
          ]
        },
        {
          "field": "isRb",
          "description": "Flag that indicates whether this level is a ring-buffer level (1) or not (0). I.e. this level stores the last 'nT' frames, and discards old data as new data comes in (if the old data has already been read by all registered readers; if this is not the case, the level will report that it is full to the writer attempting the write operation)",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "nT",
          "description": "The size of the level buffer in frames (this overwrites the 'lenSec' option)",
          "type": "numeric",
          "default": 100.0
        },
        {
          "field": "T",
          "description": "The frame period of this level in seconds. Use a frame period of 0 for a-periodic levels (i.e. data that does not occur periodically)",
          "type": "numeric",
          "default": 0.0
        },
        {
          "field": "lenSec",
          "description": "The size of the level buffer in seconds",
          "type": "numeric",
          "default": 0.0
        },
        {
          "field": "frameSizeSec",
          "description": "The size of one frame in seconds. (This is generally NOT equal to 1/T, because frames may overlap)",
          "type": "numeric",
          "default": 0.0
        },
        {
          "field": "growDyn",
          "description": "Supported currently only if 'ringbuffer=0'. If this option is set to 1, the level grows dynamically, if more memory is needed. You can use this to store live input of arbitrary length in memory. However, be aware that if openSMILE runs for a long time, it will allocate more and more memory!",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "noHang",
          "description": "This option controls the 'hang' behaviour for ring-buffer levels, i.e. the behaviour exhibited, when the level is full because data from the ring-buffer has not been marked as read because not all readers registered to read from this level have read data. Valid options are, 0, 1, 2 :\n   0 = always wait for readers, mark the level as full and make writes fail until all readers have read at least the next frame from this level\n   1 = don't wait for readers, if no readers are registered, i.e. this level is a dead-end (this is the default) / 2 = never wait for readers, writes to this level will always succeed (reads to non existing data regions might then fail), use this option with a bit of caution.",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0,
            2.0
          ]
        }
      ]
    },
    {
      "object": "arffClass",
      "fields": [
        {
          "field": "name",
          "description": "The name of the target attribute",
          "type": "string",
          "default": "class"
        },
        {
          "field": "type",
          "description": "The type of the target attribute: 'numeric', 'string', or nominal (= list of classes, enclosed in {} )",
          "type": "string",
          "default": "numeric"
        }
      ]
    },
    {
      "object": "arffTarget",
      "fields": [
        {
          "field": "instance",
          "description": "An array containing a target for each instance",
          "type": "string",
          "default": ""
        },
        {
          "field": "all",
          "description": "Assign this one target to all processed instances. You can use this option if you pass only one instance to cArffSink when openSMILE is run. (This option is used by a lot batch feature extraction scripts)",
          "type": "string",
          "default": ""
        }
      ]
    },
    {
      "object": "cDataWriterShs",
      "baseComponent": "cDataWriter",
      "fields": [
        {
          "field": "dmLevel",
          "description": "The data memory level this writer will write data to. You can specify any name here, this writer will register and create a level of this name in the dataMemory during initialisation of openSMILE. Please be aware of the fact that only one writer can write to a data memory level, therefore you are not allowed to use the same name again in a 'dmLevel' option of any other component in the same config.",
          "type": "string",
          "default": "___shs__dummy__",
          "required": true
        }
      ]
    },
    {
      "object": "cComponentManagerInst",
      "fields": [
        {
          "field": "type",
          "description": "name of component type to create an instance of",
          "type": "string",
          "default": null,
          "typeHint": "componentType"
        },
        {
          "field": "configInstance",
          "description": "config instance to connect to component instance (UNTESTED?)",
          "type": "string",
          "default": null
        },
        {
          "field": "threadId",
          "description": "thread nr. to run this component in (default = -1: either run in 1st thread or automatically run each component in one thread if nThread==0)",
          "type": "numeric",
          "default": -1.0
        }
      ]
    }
  ],
  "components": [
    {
      "component": "cDataMemory",
      "description": "central data memory component",
      "fields": [
        {
          "field": "isRb",
          "description": "The default for the isRb option for all levels.",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "nT",
          "description": "The default level buffer size in frames for all levels.",
          "type": "numeric",
          "default": 100.0
        },
        {
          "field": "level",
          "description": "An associative array containing the level configuration (obsolete, you should use the cDataWriter configuration in the components that write to the dataMemory to properly configure the dataMemory!)",
          "type": "cDataMemoryLevel"
        }
      ]
    },
    {
      "component": "cDataSelector",
      "description": "This component copies data from one level to another, thereby selecting frame fields and elements by their element/field name.",
      "readsFromLevels": [
        "reader.dmLevel"
      ],
      "writesToLevels": [
        "writer.dmLevel"
      ],
      "baseComponent": "cDataProcessor",
      "fields": [
        {
          "field": "selFile",
          "description": "The name of the data selection file to load. The file is a text file containing one element name or range of indices per line of the elements which should be selected (case-sensitive!). (Note: the first two lines make up a header; the first line is either 'str' or 'idx', the second line is number of following lines in the file, next each line contains one feature name or index range of the features to select)",
          "type": "string",
          "default": null
        },
        {
          "field": "selected",
          "description": "This is an alternative to loading 'selFile'. An array of exact (case-sensitive) names of features / data elements to select.",
          "type": "string",
          "default": null
        },
        {
          "field": "selectedRange",
          "description": "This is an alternative to loading 'selFile'. It specifies the selected elements(!) by element index ranges. Each array element contains one range in the format of <start>-<end>, where <start> and <end> are the indicies of the startt and end features to *select* in this range. '$' specifies the last element, and '1' indicates the first element. If the '-' is missing, only a single element will be selected, not a range. NOTE: the 'newNames' option does not work in conjunction with this element selection method!",
          "type": "string",
          "default": null
        },
        {
          "field": "newNames",
          "description": "An array of new names to assign to the selected features / data elements (optional). The order thereby corresponds to the order of data element names in the input.",
          "type": "string",
          "default": null
        },
        {
          "field": "elementMode",
          "description": "1 = select elements exactly as given in 'selected' array or in 'selFile' (in this case, only full element names are allowed (i.e. mfcc[1], mfcc[2] instead of mfcc, mfcc[], or mfcc[1-2]\n   0 = automatically copy arrays or partial arrays, e.g. if field[1-4] or only 'field' is given as name in the selction array/file, then the partial (1-4) or complete field will be copied to the output",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "dummyMode",
          "description": "1 = don't set up output level names. Use this option temporarily, to get a working set-up where you can read the input level names, to set up your selection list.",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "outputSingleField",
          "description": "If this is set to a string, the output will be a single field (with the name set by this string) for all the elements in the input.",
          "type": "string",
          "default": null
        }
      ]
    },
    {
      "component": "cVectorProcessor",
      "description": "dataProcessor, where each array field is processed individually as a vector",
      "readsFromLevels": [
        "reader.dmLevel"
      ],
      "writesToLevels": [
        "writer.dmLevel"
      ],
      "baseComponent": "cDataProcessor",
      "fields": [
        {
          "field": "processArrayFields",
          "description": "1 = process each array field as one vector individually (and produce one output for each input array field). Only array fields (i.e. fields with more than one element) are processed if this is set. / 0 = process complete input frame as one vector, ignoring field/element structure",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "includeSingleElementFields",
          "description": "1 = if in processArrayFields (1) mode, then also include single element fields.",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "preserveFieldNames",
          "description": "1 = when processArrrayFields is disabled (0), then still preserve the input field partitioning and names in the output, but just process the whole vector instead of fields. This was the default in old versions, but now it can be controlled. This is what you would usually want, except if you want/need to combine inputs to a single large array field.",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        }
      ]
    },
    {
      "component": "cVectorTransform",
      "description": "this is a base class for vector transforms which require history data or precomputed data (e.g. cepstral mean subtraction, etc.)",
      "readsFromLevels": [
        "reader.dmLevel"
      ],
      "writesToLevels": [
        "writer.dmLevel"
      ],
      "baseComponent": "cVectorProcessor",
      "fields": [
        {
          "field": "nameAppend",
          "description": "A string suffix to append to the input field names (default: empty)",
          "type": "string",
          "default": null
        },
        {
          "field": "mode",
          "description": "The mode of operation:\n   an(alysis) : analyse all incoming data and compute transform for later use\n   tr(ansformation) : use pre-computed transform loaded from initFile, no on-line adaptation\n   in(cremental) : use initFile as inital transform, if given, update transform on-line using 'updateMethod'",
          "type": "string",
          "default": "analysis",
          "allowedValues": [
            "an",
            "analysis",
            "tr",
            "transform",
            "transformation",
            "in",
            "incremental"
          ],
          "suggestedValues": [
            "an",
            "analysis",
            "tr",
            "transformation",
            "in",
            "incremental"
          ]
        },
        {
          "field": "initFile",
          "description": "The file to load the (initial) transformation data from (see vectorTransform.cpp for documentation of the file format). Default (null) disables loading, also setting the value to '?' disables loading of the file (parameters are initialized with 0, use mode incremental or analysis in this case.)",
          "type": "string",
          "default": null
        },
        {
          "field": "saveFile",
          "description": "The file to save transformation data to (see vectorTransform.cpp for documentation of the file format)",
          "type": "string",
          "default": null
        },
        {
          "field": "saveFileInterval",
          "description": "If set to > 0, saves transform data update only every N-th frame. For 0 it only saves at the end. Set to 1 to save for every frame (costly!!)",
          "type": "numeric",
          "default": 0.0
        },
        {
          "field": "updateMethod",
          "description": "Method to use for incrementally updating the transform. Can be one of the following:\n   'exp'  exponential: m1 = alpha * m0  + (1-alpha) * x\n   'fix'/'buf'  compute transform over history buffer of fixed length\n   'ifix'/'ibuf'  compute transform over history buffer of fixed length and use init data from last turn (see weight option)\n   'usr'  other update method (usually defined by a descendant component of cVectorTransform, look for customUpdateMethod option)\n   'avg'  cummulative average method with weighted fixed inital values\n   'iavg'  cummulative average method with weighted variable (from the last turn) inital values\n   NOTE: if 'resetOnTurn'==0 then 'avg' and 'iavg' are identical",
          "type": "string",
          "default": "iavg",
          "allowedValues": [
            "exp",
            "fix",
            "buf",
            "ifix",
            "ibuf",
            "usr",
            "avg",
            "iavg"
          ]
        },
        {
          "field": "alpha",
          "description": "The weighting factor alpha for exponential transform update",
          "type": "numeric",
          "default": 0.995
        },
        {
          "field": "weight",
          "description": "The weighting factor for 'avg'/'avgI'/'bufI' update, i.e. the factor the initial transform parameters are weighted by when building the cummulative average",
          "type": "numeric",
          "default": 100.0
        },
        {
          "field": "fixedBuffer",
          "description": "The size of the fixed length buffer [in seconds] (for fixed buffer update method)",
          "type": "numeric",
          "default": 5.0
        },
        {
          "field": "fixedBufferFrames",
          "description": "The size of the fixed length buffer [in frames] (for fixed buffer update method). Use this when the input level is aperiodic (e.g. functionals).",
          "type": "numeric",
          "default": 10.0
        },
        {
          "field": "turnOnlyUpdate",
          "description": "1 = perform transform update only during turns (between turnStart and turnEnd messages) (works for all methods)",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "invertTurn",
          "description": "1 = invert the turn state (i.e. changes a 'turnOnly...' option into 'notTurn' option)",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "resetOnTurn",
          "description": "1 = reset transform values at the beginning of each new turn (only in mode 'analysis' and 'incremental')",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "updateMaxSec",
          "description": "If update enabled, only update on the first X seconds of data if the value is > 0",
          "type": "numeric",
          "default": 0.0
        },
        {
          "field": "turnOnlyNormalise",
          "description": "1 = apply the transform only to turns (in between data will pass through unmodified) ('invertTurn' will also invert this option)",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "turnOnlyOutput",
          "description": "1 = output data to writer level only during a turn (this will implicitely set turnOnlyNormalise = 1) ('invertTurn' will also invert this option)",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "htkcompatible",
          "description": "A flag that indicates (if set to 1) whether last coefficient in 'initFile' is loaded into means[0] (use this only when reading htk-compatible cmn init files, and NOT using htk-compatible mfccs)",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "invertMVNdata",
          "description": "1 = invert the loaded MVN data to 'unstandardise' to these parameters. Currently only works with MVn text and old MVN binary data. mu' = -mu/sigma and sigma' = 1/sigma ;",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "turnStartMessage",
          "description": "You can use this option to define a custom message name for the turn start message, i.e. if you want to use voice activity start/end messages instead",
          "type": "string",
          "default": "turnStart"
        },
        {
          "field": "turnEndMessage",
          "description": "You can use this option to define a custom message name for the turn end message, i.e. if you want to use voice activity start/end messages instead",
          "type": "string",
          "default": "turnEnd"
        }
      ]
    },
    {
      "component": "cWindowProcessor",
      "description": "filter dataProcessor, filters each element in a dataMemory level independently",
      "readsFromLevels": [
        "reader.dmLevel"
      ],
      "writesToLevels": [
        "writer.dmLevel"
      ],
      "baseComponent": "cDataProcessor",
      "fields": [
        {
          "field": "noPostEOIprocessing",
          "description": "1 = do not process incomplete windows at the end of the input",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        }
      ]
    },
    {
      "component": "cWinToVecProcessor",
      "description": "reads input windows, outputs frame(s)",
      "readsFromLevels": [
        "reader.dmLevel"
      ],
      "writesToLevels": [
        "writer.dmLevel"
      ],
      "baseComponent": "cDataProcessor",
      "fields": [
        {
          "field": "blocksize",
          "description": "The size of data blocks to process in frames (this sets both blocksizeR and blocksizeW, and overwrites blocksize_sec)",
          "type": "numeric",
          "default": 0.0
        },
        {
          "field": "blocksizeR",
          "description": "The size of data blocks to read in frames (overwrites blocksize)",
          "type": "numeric",
          "default": 0.0
        },
        {
          "field": "blocksizeW",
          "description": "The size of data blocks to write in frames (overwrites blocksize)",
          "type": "numeric",
          "default": 0.0
        },
        {
          "field": "blocksize_sec",
          "description": "size of data blocks to process in seconds (this sets both blocksizeR_sec and blocksizeW_sec)",
          "type": "numeric",
          "default": 0.0
        },
        {
          "field": "blocksizeR_sec",
          "description": "size of data blocks to read in seconds (overwrites blocksize_sec!)",
          "type": "numeric",
          "default": 0.0
        },
        {
          "field": "blocksizeW_sec",
          "description": "size of data blocks to write in seconds (overwrites blocksize_sec!)",
          "type": "numeric",
          "default": 0.0
        },
        {
          "field": "allowLastFrameIncomplete",
          "description": "If this option is set to 1 (true) then in frameMode 'fixed', the last frame will be processed, even if it is not frameSize frames long.",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "frameMode",
          "description": "Specifies how to create frames: 'fixed' (fixed frame size, given via 'frameSize' option), 'full' (create one frame at the end of the input only), 'variable' (via message), 'list' (in config file or external text file, see frameList and frameListFile options, UNIMPLEMENTED)",
          "type": "string",
          "default": "fixed",
          "allowedValues": [
            "fixed",
            "fix",
            "full",
            "ful",
            "variable",
            "var",
            "list",
            "message",
            "msg",
            "meta"
          ],
          "suggestedValues": [
            "fixed",
            "full",
            "variable",
            "list",
            "message",
            "meta"
          ]
        },
        {
          "field": "frameListFile",
          "description": "Filename of a file with a list of frame intervals to load (text file with a comma separated list of intervals: 1-10,11-20 , etc., if no interval is specified, i.e. no - is found then consecutive frames with the given number being the frame length are assumed; first index is 0; use the suffix \"s\" after the numbers to specify intervals in seconds (e.g. 0s-2.5s); use an 'E' instead of a number for 'end of sequence')",
          "type": "string",
          "default": null
        },
        {
          "field": "frameList",
          "description": "The list of frame intervals specified directly in the configuration file (comma separated list of intervals: 1-10,11-20 , etc., if no interval is specified, i.e. no - is found then consecutive frames with the given number being the frame length are assumed; first index is 0; use the suffix \"s\" after the numbers to specify intervals in seconds (e.g. 0s-2.5s); use an 'E' instead of a number for 'end of sequence')",
          "type": "string",
          "default": null
        },
        {
          "field": "frameSize",
          "description": "The frame size in seconds (0.0 = full input, same as frameMode=full)",
          "type": "numeric",
          "default": 0.025
        },
        {
          "field": "frameStep",
          "description": "The frame step (frame sampling period) in seconds (0.0 = set to the same value as 'frameSize')",
          "type": "numeric",
          "default": 0.0
        },
        {
          "field": "frameSizeFrames",
          "description": "The frame size in input level frames (=samples for a pcm/wave input level) (overrides frameSize, if set and > 0)",
          "type": "numeric",
          "default": 0.0
        },
        {
          "field": "frameStepFrames",
          "description": "The frame step in input level frames (=samples for a pcm/wave input level) (overrides frameStep, if set and > 0)",
          "type": "numeric",
          "default": 0.0
        },
        {
          "field": "frameCenter",
          "description": "The frame center in seconds, i.e. where frames are sampled (0=left)",
          "type": "numeric",
          "default": 0.0
        },
        {
          "field": "frameCenterFrames",
          "description": "The frame sampling center in input level frames (overrides frameCenter, if set), (0=left)",
          "type": "numeric",
          "default": 0.0
        },
        {
          "field": "frameCenterSpecial",
          "description": "The frame sampling center (overrides the other frameCenter options, if set). The available special frame sampling points as strings are: 'mid' = middle (first frame from -frameSize/2 to frameSize/2), 'left' = sample at the beginning of the frame (first frame from 0 to frameSize), 'right' = sample at the end of the frame (first frame from -frameSize to 0)",
          "type": "string",
          "default": "left",
          "allowedValues": [
            "left",
            "mid",
            "middle",
            "right",
            "center"
          ],
          "suggestedValues": [
            "left",
            "mid",
            "right"
          ]
        },
        {
          "field": "noPostEOIprocessing",
          "description": "1 = do not process incomplete windows at the end of the input",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        }
      ]
    },
    {
      "component": "cVecToWinProcessor",
      "description": "Base class: reads in frames , outputs windows",
      "readsFromLevels": [
        "reader.dmLevel"
      ],
      "writesToLevels": [
        "writer.dmLevel"
      ],
      "baseComponent": "cDataProcessor",
      "fields": [
        {
          "field": "blocksize",
          "description": "The size of data blocks to process in frames (this sets both blocksizeR and blocksizeW, and overwrites blocksize_sec)",
          "type": "numeric",
          "default": 0.0
        },
        {
          "field": "blocksizeR",
          "description": "The size of data blocks to read in frames (overwrites blocksize)",
          "type": "numeric",
          "default": 0.0
        },
        {
          "field": "blocksizeW",
          "description": "The size of data blocks to write in frames (overwrites blocksize)",
          "type": "numeric",
          "default": 0.0
        },
        {
          "field": "blocksize_sec",
          "description": "size of data blocks to process in seconds (this sets both blocksizeR_sec and blocksizeW_sec)",
          "type": "numeric",
          "default": 0.0
        },
        {
          "field": "blocksizeR_sec",
          "description": "size of data blocks to read in seconds (overwrites blocksize_sec!)",
          "type": "numeric",
          "default": 0.0
        },
        {
          "field": "blocksizeW_sec",
          "description": "size of data blocks to write in seconds (overwrites blocksize_sec!)",
          "type": "numeric",
          "default": 0.0
        },
        {
          "field": "forceSampleRate",
          "description": "Set a given sample rate for the output level. Typically the base period of the input level will be used for this purpose, but when reading frame-based data from feature files, for example, this information is not available. This option overwrites the input level base period, if it is set.",
          "type": "numeric",
          "default": 16000.0
        },
        {
          "field": "normaliseAdd",
          "description": "1/0 (on/off) : normalise frames before adding to eliminate envelope fluctuation artefacts and scaling artefacts. When this is enabled the output should always be correctly scaled to the range -1 and +1. If this is deactivated perfect reconstruction can only be guaranteed with root-raised cosine windows and 50 percent overlap.",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "useWinAasWinB",
          "description": "1 = use window A as window B (e.g. if win A is a root of window x function, e.g. root raised cosine). The 'windowB' must be left blank, and NO windower must be present between the ifft (or other processing) and this component. This component will internally apply window function A before doing the overlap add. (NOT YET IMPLEMENTED)",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "gain",
          "description": "A gain to apply to the output samples.",
          "type": "numeric",
          "default": 1.0
        },
        {
          "field": "windowA",
          "description": "Name of cWindower component applied before transforming into the spectral domain. Leave empty to use constant window (=1).",
          "type": "string",
          "default": null,
          "typeHint": "componentInstance"
        },
        {
          "field": "windowB",
          "description": "Name of cWindower component applied after transforming back into the time domain. Leave empty to use constant window (=1).",
          "type": "string",
          "default": null,
          "typeHint": "componentInstance"
        },
        {
          "field": "processArrayFields",
          "description": "If turned on (1), process array fields individually. If turned off (0), treat the input vector as a single field/frame.",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "noPostEOIprocessing",
          "description": "1 = do not process incomplete windows at end of input",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        }
      ]
    },
    {
      "component": "cExampleSource",
      "description": "This is an example of a cDataSource descendant. It writes random data to the data memory. This component is intended as a template for developers.",
      "writesToLevels": [
        "writer.dmLevel"
      ],
      "baseComponent": "cDataSource",
      "fields": [
        {
          "field": "nValues",
          "description": "The number of random values to generate",
          "type": "numeric",
          "default": 1.0
        },
        {
          "field": "randSeed",
          "description": "The random seed",
          "type": "numeric",
          "default": 1.0
        }
      ]
    },
    {
      "component": "cExampleSink",
      "description": "This is an example of a cDataSink descendant. It reads data from the data memory and prints it to the console. This component is intended as a template for developers.",
      "readsFromLevels": [
        "reader.dmLevel"
      ],
      "baseComponent": "cDataSink",
      "fields": [
        {
          "field": "filename",
          "description": "The name of a text file to dump values to (this file will be overwritten, if it exists)",
          "type": "string",
          "default": null
        },
        {
          "field": "lag",
          "description": "Output data <lag> frames behind",
          "type": "numeric",
          "default": 0.0
        }
      ]
    },
    {
      "component": "cVectorConcat",
      "description": "concatenates vectors from multiple levels and copy to another level",
      "readsFromLevels": [
        "reader.dmLevel"
      ],
      "writesToLevels": [
        "writer.dmLevel"
      ],
      "baseComponent": "cVectorProcessor",
      "fields": []
    },
    {
      "component": "cFramer",
      "description": "This component creates frames from single dimensional input stream. It is possible to specify the frame step and frame size independently, thus allowing for overlapping frames or non continuous frames.",
      "readsFromLevels": [
        "reader.dmLevel"
      ],
      "writesToLevels": [
        "writer.dmLevel"
      ],
      "baseComponent": "cWinToVecProcessor",
      "fields": []
    },
    {
      "component": "cWindower",
      "description": "This component applies applies window function to pcm frames.",
      "readsFromLevels": [
        "reader.dmLevel"
      ],
      "writesToLevels": [
        "writer.dmLevel"
      ],
      "baseComponent": "cVectorProcessor",
      "fields": [
        {
          "field": "gain",
          "description": "This option allows you to specify a scaling factor by which window function (which is by default normalised to max. 1) should be multiplied by",
          "type": "numeric",
          "default": 1.0
        },
        {
          "field": "offset",
          "description": "This specifies an offset which will be added to the samples after multiplying with the window function",
          "type": "numeric",
          "default": 0.0
        },
        {
          "field": "xscale",
          "description": "(NOT YET IMPLEMENTED!) A scale factor applied to the y-axis when computing the window. A factor of 2 will compute the window over twice the window length, and then clip it to the window, i.e. only the left half of the window function will be the actual window. In case of xscale=0.5, for example, the second half of the actual window will be zero, while the first half is the window function. Use in conjunction with 'xshift' paramter.",
          "type": "numeric",
          "default": 1.0
        },
        {
          "field": "xshift",
          "description": "Specifies a shift of the window center to the left (negative) or right (positive) as percentage of the window length (ignoring xscale parameter). Allowed range is from -100% to +100%.",
          "type": "numeric",
          "default": 0.0
        },
        {
          "field": "winFunc",
          "description": "Window function:\n   Hann [Han] (= raised cosine window; use this, if you want to resynthesis from the spectral domain, also use 50% overlap in the framer!),\n   Hamming [Ham],\n   Rectangular [Rec],\n   Gauss [Gau],\n   Sine / Cosine [Sin],\n   Triangular [Tri],\n   Bartlett [Bar],\n   Bartlett-Hann [BaH],\n   Blackmann [Bla],\n   Blackmann-Harris [BlH],\n   Lanczos [Lac]",
          "type": "string",
          "default": "Han",
          "allowedValues": [
            "Han",
            "han",
            "Hanning",
            "hanning",
            "hann",
            "Hann",
            "Ham",
            "ham",
            "Hamming",
            "hamming",
            "Rec",
            "rec",
            "Rectangular",
            "rectangular",
            "none",
            "None",
            "Gau",
            "gau",
            "Gauss",
            "gauss",
            "Gaussian",
            "gaussian",
            "Sin",
            "sin",
            "Sine",
            "sine",
            "cosine",
            "Cosine",
            "Cos",
            "cos",
            "Tri",
            "tri",
            "Triangle",
            "triangle",
            "Bar",
            "bar",
            "Bartlett",
            "bartlett",
            "BaH",
            "bah",
            "Bartlett-Hann",
            "bartlett-hann",
            "Bartlett-Hanning",
            "bartlett-hanning",
            "Bla",
            "bla",
            "Blackman",
            "blackman",
            "BlH",
            "blh",
            "Blackman-Harris",
            "blackman-harris",
            "Lac",
            "lac",
            "Lanczos",
            "lanczos"
          ],
          "suggestedValues": [
            "Han",
            "Ham",
            "Rec",
            "Gau",
            "Sin",
            "Tri",
            "Bar",
            "BaH",
            "Bla",
            "BlH",
            "Lac"
          ]
        },
        {
          "field": "sigma",
          "description": "Standard deviation for the Gaussian window relative to half the window length. I.e. at N/2 - (N/2 * sigma) the window amplitude will be 0.5.",
          "type": "numeric",
          "default": 0.4
        },
        {
          "field": "alpha0",
          "description": "alpha0 for Blackmann(-Harris) / Bartlett-Hann windows (optional!)",
          "type": "numeric",
          "default": 0.0
        },
        {
          "field": "alpha1",
          "description": "alpha1 for Blackmann(-Harris) / Bartlett-Hann windows (optional!)",
          "type": "numeric",
          "default": 0.0
        },
        {
          "field": "alpha2",
          "description": "alpha2 for Blackmann(-Harris) / Bartlett-Hann windows (optional!)",
          "type": "numeric",
          "default": 0.0
        },
        {
          "field": "alpha3",
          "description": "alpha3 for Blackmann-Harris window (optional!)",
          "type": "numeric",
          "default": 0.0
        },
        {
          "field": "alpha",
          "description": "alpha for the Blackmann window",
          "type": "numeric",
          "default": 0.16
        },
        {
          "field": "fade",
          "description": "Fade percentage (0 - 0.5) for fading edges to 0 with a half raised cosine function (0 = no fade, default)",
          "type": "numeric",
          "default": 0.0
        },
        {
          "field": "squareRoot",
          "description": "1 = use square root of 'winFunc' as actual window function (e.g. to get a root raised cosine window).",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "saveWindowToFile",
          "description": "Save window to text file (comma separated coefficients) of given name. If NULL (default) nothing will be saved.",
          "type": "string",
          "default": null
        }
      ]
    },
    {
      "component": "cVectorOperation",
      "description": "This component performs elementary operations on vectors (i.e. basically everything that does not require history or context, everything that can be performed on single vectors w/o external data (except for constant parameters, etc.))",
      "readsFromLevels": [
        "reader.dmLevel"
      ],
      "writesToLevels": [
        "writer.dmLevel"
      ],
      "baseComponent": "cVectorProcessor",
      "fields": [
        {
          "field": "operation",
          "description": "A string which specifies the type of operation to perform:\n   norm = normalise vector length (euclidean norm, L2) to 1\n   nr1 = normalise range to +1, -1\n   nr0 = normalise range to +1, 0\n   nma = divide by the maximum absolute value\n   mul = multiply vector by param1\n   add = add param1 to each element\n   log = compute natural logarithm\n   lgA = compute logarithm to base param1\n   nl1 = normalise vector sum (L1 norm) to 1\n   sqrt = compute square root\n   pow = take values to the power of param1\n   exp = raise param1 to the power of the vector elements\n   ee = raise the base e to the power of the vector elements\n   abs = take absolute value of each element\n   agn = add Gaussian noise with mean param1 and std.dev. param2\n   min = take the min of vector and param1\n   max = take the max of vector and param1\n   sum = compute sum of vector elements, there will be a single output only\n   ssm = compute sum of squared vector elements, there will be a single output only\n   ll1 = compute sum of vector elements normalised by the number of vector elements, there will be a single output only\n   ll2 = compute euclidean length (root of sum of squares normalised by vector length), there will be a single output only\n   fla(tten) = flattening of comb filter energy spectra, as in 2007 ICASSP Paper and Ballroom dance style recognition.\n   dBp = convert a power to decibel with 10*log10(x).\n   dBv = convert an amplitude/magnitude/voltage to decibel with 20*log10(x)\n   fconv_aaa_bbb = convert frequency from scale aaa to scale bbb\n     lin = linear (Hz)\n     bark = Bark (Traunmueller, 1990)\n     mel = Mel-scale\n     oct = semitone/octave scale (music), param1 = freq. of first note in Hz.",
          "type": "string",
          "default": "norm",
          "allowedValues": [
            "norm",
            "nr1",
            "nr0",
            "nma",
            "mul",
            "add",
            "log",
            "lgA",
            "nl1",
            "sqrt",
            "pow",
            "exp",
            "ee",
            "abs",
            "agn",
            "min",
            "max",
            "sum",
            "ssm",
            "ll1",
            "ll2",
            "fla",
            "flatten",
            "dBp",
            "dBv",
            "fconv_lin_bark",
            "fconv_lin_mel",
            "fconv_lin_oct",
            "fconv_bark_lin",
            "fconv_bark_mel",
            "fconv_bark_oct",
            "fconv_mel_lin",
            "fconv_mel_bark",
            "fconv_mel_oct",
            "fconv_oct_lin",
            "fconv_oct_bark",
            "fconv_oct_mel"
          ]
        },
        {
          "field": "param1",
          "description": "parameter 1",
          "type": "numeric",
          "default": 1.0
        },
        {
          "field": "param2",
          "description": "parameter 2",
          "type": "numeric",
          "default": 1.0
        },
        {
          "field": "logfloor",
          "description": "floor for log operation",
          "type": "numeric",
          "default": 1e-12
        },
        {
          "field": "powOnlyPos",
          "description": "if 'operation' = 'pow', do not take negative values to the power of 'param1'; instead, output 0. This is necessary to avoid 'nan' values if the exponent is rational.",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "nameBase",
          "description": "base of output feature name when performing n->1 mapping operations (currently 'euc' and 'sum')",
          "type": "string",
          "default": null
        },
        {
          "field": "appendOperationToName",
          "description": "(1/0 = yes/no) append the operation name from the 'operation' option to the feature name. This will override any nameAppend option (inherited from cDataProcessor).",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        }
      ]
    },
    {
      "component": "cValbasedSelector",
      "description": "This component copies only those frames from the input to the output that match a certain threshold criterion, i.e. where a specified value N exceeds a certain threshold.",
      "readsFromLevels": [
        "reader.dmLevel"
      ],
      "writesToLevels": [
        "writer.dmLevel"
      ],
      "baseComponent": "cDataProcessor",
      "fields": [
        {
          "field": "threshold",
          "description": "Threshold for selection (see also 'invert' option)",
          "type": "numeric",
          "default": 1.0
        },
        {
          "field": "adaptiveThreshold",
          "description": "1/0 = on/off, use an adaptive threshold given by a running average (see adaptationLength[Sec] option).",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "adaptationLengthSec",
          "description": "Length of running average for adaptive threshold in seconds",
          "type": "numeric",
          "default": 2.0
        },
        {
          "field": "adaptationLength",
          "description": "Length of running average for adaptive threshold in frames (if set, overrides the adaptationLengthSec; also used as default if neither option is specified)",
          "type": "numeric",
          "default": 200.0
        },
        {
          "field": "debugAdaptiveThreshold",
          "description": "If > 0, the interval (in frames) at which to output the current adaptive threshold to the log at log-level 3.",
          "type": "numeric",
          "default": 0.0
        },
        {
          "field": "idx",
          "description": "The index of element to base the selection decision on. Currently only 1 element is supported, NO vector based thresholds etc. are possible.",
          "type": "numeric",
          "default": 0.0
        },
        {
          "field": "invert",
          "description": "1 = output the frame when element[idx] < threshold ; 0 = output the frame if element[idx] => threshold",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "allowEqual",
          "description": "if this option is set to 1, output the frame also, when element[idx] == threshold",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "removeIdx",
          "description": "1 = remove field element[idx] in output vector ; 0 = keep it",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "zeroVec",
          "description": "1 = instead of not writing output to the output level if selection threshold is not met, output a vector with all values set to 'outputVal', which is 0 by default (removeIdx options still has the same effect).",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "outputVal",
          "description": "Value all output elements will be set to when 'zeroVec=1'.",
          "type": "numeric",
          "default": 0.0
        }
      ]
    },
    {
      "component": "cMaxIndex",
      "description": "This component computes the indices of the features with the maximum absolute values per frame.",
      "readsFromLevels": [
        "reader.dmLevel"
      ],
      "writesToLevels": [
        "writer.dmLevel"
      ],
      "baseComponent": "cVectorProcessor",
      "fields": [
        {
          "field": "nameAppend",
          "description": "A string suffix to append to the input field names (default: empty)",
          "type": "string",
          "default": "maxIndex"
        },
        {
          "field": "nIndices",
          "description": "The number of indices to compute",
          "type": "numeric",
          "default": 1.0
        },
        {
          "field": "minFeature",
          "description": "Start with this feature in computing the maximum index (1 = first feature)",
          "type": "numeric",
          "default": 1.0
        },
        {
          "field": "maxFeature",
          "description": "End with this feature in computing the maximum index (0 = last feature)",
          "type": "numeric",
          "default": 0.0
        },
        {
          "field": "randNoise",
          "description": "If > 0, add random noise with given range (+-'randNoise') to index values.",
          "type": "numeric",
          "default": 0.0
        }
      ]
    },
    {
      "component": "cFullinputMean",
      "description": "This component performs mean normalizing on a data series. A 2-pass analysis of the data is performed, which makes this component unusable for on-line analysis. In the first pass, no output is produced and the mean value (over time) is computed for each input element. In the second pass the mean vector is subtracted from all input frames, and the result is written to the output dataMemory level. Attention: Due to the 2-pass processing the input level must be large enough to hold the whole data sequence.",
      "readsFromLevels": [
        "reader.dmLevel"
      ],
      "writesToLevels": [
        "writer.dmLevel"
      ],
      "baseComponent": "cDataProcessor",
      "fields": [
        {
          "field": "mvn",
          "description": "1 = perform mean + variance (stddev) normalisation, overrides 'meanNorm' option and forces meanNorm=amean.",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "meanNorm",
          "description": "Type of mean normalisation: amean, rqmean, absmean  (arithmetic, root squared/quadratic, absolute value mean).",
          "type": "string",
          "default": "amean",
          "allowedValues": [
            "amean",
            "rqmean",
            "absmean"
          ]
        },
        {
          "field": "symmSubtract",
          "description": "1 = Perform symmetric subtraction of rqmean or absmean u. I.e. for negative values add u and for positive values subtract u.",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "subtractClipToZero",
          "description": "1 = If symmSubtract is enabled and a value would change sign, clip it to 0. Otherwise, clip negative values to 0 when subtracting any kind of mean. 0 = do nothing special.",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "specEnorm",
          "description": "performs spectral magnitude energy normalisation",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "htkLogEnorm",
          "description": "performs HTK compatible energy normalisation on all input fields instead of the default action of mean subtraction. The energy normalisation subtracts the maximum value of each value in the sequence and adds 1.",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "multiLoopMode",
          "description": "1 = Support the new tick loop mode which can have unlimited EOI iterations. In this mode the means will be collected until the EOI condition is signalled. During the EOI condition nothing will be done (except computing means from the remaining data). During the next non EOI condition, the means will be subtracted from the old input, and (if new data is available - e.g. from a next segment) a new set of means will be computed. If old and new data is processed, the cycle begins anew. If this option is disabled, the means are subtracted while the first EOI condition is signalled. This is for compatibility with old behaviour of the tick loop.",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "printMeans",
          "description": "1 = print the mean vector once it has been computed.",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "printStddevs",
          "description": "1 = print the standard deviation vector once it has been computed (if MVN=1 is set).",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "excludeZeros",
          "description": "1 = exclude 0 values or NaN values from mean/variance computation and normalistaion. Use e.g. for F0 contours. Only supported for mean type 'amean'.",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        }
      ]
    },
    {
      "component": "cFullturnMean",
      "description": "This component performs mean normalizing on a data series. A 2-pass analysis of the data is performed, which makes this component unusable for on-line analysis. In the first pass, no output is produced and the mean value (over time) is computed for each input element. In the second pass the mean vector is subtracted from all input frames, and the result is written to the output dataMemory level. Attention: Due to the 2-pass processing the input level must be large enough to hold the whole data sequence.",
      "readsFromLevels": [
        "reader.dmLevel"
      ],
      "writesToLevels": [
        "writer.dmLevel"
      ],
      "sendsMessagesToComponents": [
        "messageRecp"
      ],
      "baseComponent": "cDataProcessor",
      "fields": [
        {
          "field": "htkLogEnorm",
          "description": "performs HTK compatible energy normalisation on all input fields instead of the default action of mean subtraction. The energy normalisation subtracts the maximum value of each value in the sequence and adds 1.",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "messageRecp",
          "description": "recipient list for new (timestamp adjusted) turnFrameTime message",
          "type": "string",
          "default": null,
          "typeHint": "componentInstance"
        }
      ]
    },
    {
      "component": "cWaveSource",
      "description": "This component reads an uncompressed RIFF (PCM-WAVE) file and saves it as a stream to the data memory.",
      "writesToLevels": [
        "writer.dmLevel"
      ],
      "baseComponent": "cDataSource",
      "fields": [
        {
          "field": "blocksize_sec",
          "description": "The size of data blocks to write at once, in seconds",
          "type": "numeric",
          "default": 1.0
        },
        {
          "field": "filename",
          "description": "The filename of the PCM wave file to load. Only uncompressed RIFF files are supported. Use a suitable converter (mplayer, for example) to convert other formats to wave.",
          "type": "string",
          "default": "input.wav",
          "required": true
        },
        {
          "field": "properTimestamps",
          "description": "1 = set smileTime for every input sample based on sample time (a bit inefficient); otherwise the default is to use the current system time at which the samples are read from the file.",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "monoMixdown",
          "description": "Mix down all channels to 1 mono channel (1=on, 0=off)",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "start",
          "description": "The read start point in seconds from the beginning of the file",
          "type": "numeric",
          "default": 0.0
        },
        {
          "field": "end",
          "description": "The read end point in seconds from the beginning of file (-1 = read to EoF)",
          "type": "numeric",
          "default": -1.0
        },
        {
          "field": "endrel",
          "description": "The read end point in seconds from the END of file (only if 'end' = -1, or not set)",
          "type": "numeric",
          "default": 0.0
        },
        {
          "field": "startSamples",
          "description": "The read start in samples from the beginning of the file (this overwrites 'start')",
          "type": "numeric",
          "default": 0.0
        },
        {
          "field": "endSamples",
          "description": "The read end in samples from the beginning of the file (this overwrites 'end' and 'endrelSamples')",
          "type": "numeric",
          "default": -1.0
        },
        {
          "field": "endrelSamples",
          "description": "The read end in samples from the END of file (this overwrites 'endrel')",
          "type": "numeric",
          "default": 0.0
        },
        {
          "field": "noHeader",
          "description": "1 = treat the input file as 'raw' format, i.e. don't read the RIFF header. You must specify the parameters 'sampleRate', 'channels', and possibly 'sampleSize' if the defaults don't match your file format",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "sampleRate",
          "description": "Set the sampling rate that is assigned to the input data when reading raw files",
          "type": "numeric",
          "default": 16000.0
        },
        {
          "field": "sampleSize",
          "description": "Set the sample size (in bytes) when reading raw files",
          "type": "numeric",
          "default": 2.0
        },
        {
          "field": "channels",
          "description": "Set the number of channels when reading raw files",
          "type": "numeric",
          "default": 1.0
        },
        {
          "field": "outFieldName",
          "description": "Set the name of the output field containing the pcm data",
          "type": "string",
          "default": "pcm"
        }
      ]
    },
    {
      "component": "cArffSource",
      "description": "This component reads WEKA ARFF files. The full ARFF format is not yet supported, but a simplified form, such as the files generated by the cArffSink component can be parsed and read. This component reads all (and only!!) 'numeric' or 'real' attributes from an ARFF file (WEKA file format) into the specified data memory level. Thereby each instance (i.e. one line in the arff file's data section) corresponds to one frame. The frame period is 0 by default (aperiodic level), use the 'period' option to change this and use a fixed period for each frame/instance. Automatic generation of frame timestamps from a 'timestamp' field in the Arff file is not yet supported.",
      "writesToLevels": [
        "writer.dmLevel"
      ],
      "baseComponent": "cDataSource",
      "fields": [
        {
          "field": "filename",
          "description": "The filename of the ARFF file to read",
          "type": "string",
          "default": "input.arff"
        },
        {
          "field": "skipFirst",
          "description": "the number of numeric(!) attributes to skip at the beginning",
          "type": "numeric",
          "default": 0.0
        },
        {
          "field": "skipClasses",
          "description": "The number of numeric(!) (or real) attributes (values) at end of each instance to skip (Note: nominal and string attributes are ignored anyway, this option only applies to the last numeric attributes, even if they are followed by string or nominal attributes). To have more fine-grained control over selecting attributes, please use the component cDataSelector!",
          "type": "numeric",
          "default": 0.0
        },
        {
          "field": "saveInstanceIdAsMetadata",
          "description": "1/0 = on/off : save the first string attribute of the arff file as instance ID string in the vector metadata (e.g. for use by the winToVecProcessor component in the frameMode=meta mode).",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "saveTargetsAsMetadata",
          "description": "1/0 = on/off : save everything after the last numeric attribute as metadata string. This can be read by arffSink and appended to the instances instead of reading individual targets from the config.",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "readFrameTime",
          "description": "1 = read frameTime from arff field 'frameTime'. The field frameTime is not automatically skipped, use the skipFirst option to skip the first N elements.",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "readFrameLength",
          "description": "1 = read frameLength from arff field 'frameLength'. The field framelength is not automatically skipped, use the skipFirst option to skip the first N elements.",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "frameTimeIndex",
          "description": "if set to >= 0, specifies the index of the attribute that is the frameTime attribute. The default (-1) will enable autodetection based on the attribute name 'frameTime'. If readFrameTime==0, then this option has no effect.",
          "type": "numeric",
          "default": -1.0
        },
        {
          "field": "frameLengthIndex",
          "description": "if set to >= 0, specifies the index of the attribute that is the frameLength attribute. The default (-1) will enable autodetection based on the attribute name 'frameLength'. If readFrameLength==0, then this option has no effect.",
          "type": "numeric",
          "default": -1.0
        }
      ]
    },
    {
      "component": "cCsvSource",
      "description": "This component reads CSV (Comma seperated value) files. It reads all columns as attributes into the data memory. One line represents one frame. The first line may contain a header with the feature names (see header=yes/no/auto option).",
      "writesToLevels": [
        "writer.dmLevel"
      ],
      "baseComponent": "cDataSource",
      "fields": [
        {
          "field": "filename",
          "description": "The CSV file to read",
          "type": "string",
          "default": "input.csv"
        },
        {
          "field": "delimChar",
          "description": "The CSV delimiter character to use. Usually ',' or ';'.",
          "type": "char",
          "default": ";"
        },
        {
          "field": "header",
          "description": "yes/no/auto : wether to read the first line of the CSV file as header (yes), or treat it as numeric data (no), or automatically determine from the first field in the first line whether to read the header or not (auto).",
          "type": "string",
          "default": "auto",
          "allowedValues": [
            "yes",
            "no",
            "auto"
          ]
        },
        {
          "field": "start",
          "description": "Start at line 'start', not counting the header line. The first line after the (optional) header line is line 0 (also the default).",
          "type": "numeric",
          "default": 0.0
        },
        {
          "field": "end",
          "description": "Read up to line 'end'. The number of the line given here is the last line that will be read. 0 is the first line in the file (excluding header). The default '-1' refers to the last line in the file (this is also the default).",
          "type": "numeric",
          "default": -1.0
        },
        {
          "field": "readFrameTime",
          "description": "1 = read frameTime from arff field 'frameTime'. The frameTime field is not loaded into dataMemory then.",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        }
      ]
    },
    {
      "component": "cHtkSource",
      "description": "This component reads data from binary HTK parameter files.",
      "writesToLevels": [
        "writer.dmLevel"
      ],
      "baseComponent": "cDataSource",
      "fields": [
        {
          "field": "blocksize",
          "description": "The size of data blocks to write at once (to data memory) in frames",
          "type": "numeric",
          "default": 10.0
        },
        {
          "field": "filename",
          "description": "HTK parameter file to read",
          "type": "string",
          "default": "input.htk"
        },
        {
          "field": "featureName",
          "description": "The name of the array-field which is to be created in the data memory output level for the data array read from the HTK file",
          "type": "string",
          "default": "htkpara"
        },
        {
          "field": "featureFrameSize",
          "description": "The size of the feature frames in seconds.",
          "type": "numeric",
          "default": 0.0
        },
        {
          "field": "forceSampleRate",
          "description": "Set a given sample rate for the output level. Typically the base period of the input level will be used for this purpose, but when reading frame-based data from feature files, for example, this information is not available. This option overwrites the input level base period, if it is set.",
          "type": "numeric",
          "default": 16000.0
        }
      ]
    },
    {
      "component": "cNullSink",
      "description": "This component reads data vectors from the data memory and 'destroys' them, i.e. does not write them anywhere. This component has no configuration options.",
      "readsFromLevels": [
        "reader.dmLevel"
      ],
      "baseComponent": "cDataSink",
      "fields": []
    },
    {
      "component": "cCsvSink",
      "description": "This component exports data in CSV (comma-separated-value) format used in many spreadsheet applications. As the first line of the CSV file a header line may be printed, which contains a delimiter separated list of field names of the output values.",
      "readsFromLevels": [
        "reader.dmLevel"
      ],
      "baseComponent": "cDataSink",
      "fields": [
        {
          "field": "filename",
          "description": "The CSV file to write to. An empty filename (or '?' as the filename) disables this sink component.",
          "type": "string",
          "default": "smileoutput.csv"
        },
        {
          "field": "delimChar",
          "description": "The column delimiter character to use (usually ',' or ';') (NOTE: use '<space>' or '<tab>' for these special characters respectively)",
          "type": "char",
          "default": ";"
        },
        {
          "field": "lag",
          "description": "output data <lag> frames behind",
          "type": "numeric",
          "default": 0.0
        },
        {
          "field": "append",
          "description": "1 = append to an existing file, or create a new file; 0 = overwrite an existing file, or create a new file",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "frameIndex",
          "description": "(same as 'number') 1 = print an instance number (= frameIndex) attribute for each output frame (1/0 = yes/no)",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "number",
          "description": "1 = print an instance number (= frameIndex) attribute for each output frame (1/0 = yes/no)",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "frameLength",
          "description": "1 = print a frame length attribute (1/0 = yes/no).",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "frameTime",
          "description": "(same as 'timestamp') 1 = print a timestamp attribute for each output frame (1/0 = yes/no)",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "timestamp",
          "description": "1 = print a timestamp attribute for each output frame (1/0 = yes/no)",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "printHeader",
          "description": "1 = print a header line as the first line in the CSV file. This line contains the attribute names separated by the delimiter character.",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "flush",
          "description": "1 = flush data to file after every line written (might give low performance for small lines!).",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "instanceBase",
          "description": "if not empty, print instance name attribute <instanceBase_Nr>",
          "type": "string",
          "default": null
        },
        {
          "field": "instanceName",
          "description": "if not empty, print instance name attribute <instanceName>",
          "type": "string",
          "default": null
        }
      ]
    },
    {
      "component": "cDatadumpSink",
      "description": "This component writes dataMemory data to a raw binary file (e.g. for matlab import). The binary file consists of 32-bit float values representing the data values, concatenated frame by frame along the time axis. The first two float values in the file are the file header, indicating the dimension of the matrix (1: size of frames, 2: number of frames in file). The total file size in bytes is thus <size of frames>x<number of frames>x4 + 2.",
      "readsFromLevels": [
        "reader.dmLevel"
      ],
      "baseComponent": "cDataSink",
      "fields": [
        {
          "field": "filename",
          "description": "The filename of the output file (if it doesn't exist it will be created).",
          "type": "string",
          "default": "datadump.dat"
        },
        {
          "field": "lag",
          "description": "output data <lag> frames behind",
          "type": "numeric",
          "default": 0.0
        },
        {
          "field": "append",
          "description": "1 = append to an existing file, or create a new file; 0 = overwrite an existing file, or create a new file",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        }
      ]
    },
    {
      "component": "cArffSink",
      "description": "This component writes dataMemory data to an ARFF file (WEKA). Depending on your config an instance name field, a frame index, and a frame time field can be added as well as multiple class/target attributes. See the config type documentation for more details.",
      "readsFromLevels": [
        "reader.dmLevel"
      ],
      "baseComponent": "cDataSink",
      "fields": [
        {
          "field": "errorOnNoOutput",
          "description": "1 = show an error message if no output was written by this sink during this run.",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "filename",
          "description": "The filename of the ARFF file to write to. An empty filename disables this sink component.",
          "type": "string",
          "default": "smileoutput.arff"
        },
        {
          "field": "lag",
          "description": "output data <lag> frames behind",
          "type": "numeric",
          "default": 0.0
        },
        {
          "field": "append",
          "description": "1 = append to an existing file, or create a new file; 0 = overwrite an existing file, or create a new file",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "relation",
          "description": "The name of the ARFF relation (@relation tag)",
          "type": "string",
          "default": "smile"
        },
        {
          "field": "instanceBase",
          "description": "If this string is not empty and not equal to '-', cArffSink prints an instance name attribute <instanceBase_Nr>, where Nr is the number (continuous index) of current instance",
          "type": "string",
          "default": ""
        },
        {
          "field": "instanceName",
          "description": "If this string is not empty and not equal to '-', cArffSink prints an instance name attribute <instanceName> for all instances. instanceName overwrites instanceBase.",
          "type": "string",
          "default": ""
        },
        {
          "field": "instanceNameFromMetadata",
          "description": "1/0 = yes/no. Use instanceName from metadata, if available. If this is not available, printing of an instance name depends on 'instanceName' and 'instanceBase' attributes.",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "useTargetsFromMetadata",
          "description": "1/0 = yes/no. Use string of target values/classes from vector metadata instead of building it from the 'target' array. If no metadata is present the target string will be built from the 'target' array",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "number",
          "description": "'Synonym' for the 'frameIndex' option: 1 = print an instance number (= frameIndex) attribute (continuous index) (1/0 = yes/no)",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "timestamp",
          "description": "'Synonym' for the 'frameTime' option: 1 = print a timestamp (=frameTime) attribute (1/0 = yes/no)",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "frameIndex",
          "description": "1 = print an instance number (= frameIndex) attribute (continuous index) (1/0 = yes/no) (same as 'number' option)",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "frameTime",
          "description": "1 = print a timestamp (=frameTime) attribute (1/0 = yes/no) (same as 'timestamp' option)",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "frameTimeAdd",
          "description": "Add this value to the framTime values (unit: seconds)",
          "type": "numeric",
          "default": 0.0
        },
        {
          "field": "frameLength",
          "description": "1 = print a frame length attribute (1/0 = yes/no).",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "class",
          "description": "This is an array defining the optional class target attributes (grund-truths that you want to have included in your arff file along with your features). It is an array for multiple targets/classes. See also the 'target' array.",
          "type": "arffClass"
        },
        {
          "field": "printDefaultClassDummyAttribute",
          "description": "1/0 = yes/no, print default class dummy attribute if no class attributes are given in the class[] array. Default is 1 for backward compatibility. Set to 0 to remove default class attribute.",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "target",
          "description": "The ground truth targets (classes) for each target (class) attribute",
          "type": "arffTarget"
        }
      ]
    },
    {
      "component": "cHtkSink",
      "description": "This component writes dataMemory data to a binary HTK parameter file.",
      "readsFromLevels": [
        "reader.dmLevel"
      ],
      "baseComponent": "cDataSink",
      "fields": [
        {
          "field": "filename",
          "description": "HTK parameter file to write to (and create)",
          "type": "string",
          "default": "smileoutput.htk"
        },
        {
          "field": "lag",
          "description": "If > 0, enable output of data <lag> frames behind",
          "type": "numeric",
          "default": 0.0
        },
        {
          "field": "append",
          "description": "1 = append to existing file (0 = don't append)",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "parmKind",
          "description": "HTK parmKind header field (0=WAVEFORM, 1=LPC, 2=LPREFC, 3=LPCEPSTRA, 4=LPDELCEP, 5=IREFC, 6=MFCC, 7=FBANK (log), 8=MELSPEC (linear), 9=USER, 10=DISCRETE, 11=PLPCC ;\n   Qualifiers (added): 64=_E, 128=_N, 256=_D, 512=_A, 1024=_C, 2048=_Z, 4096=_K, 8192=_0)",
          "type": "numeric",
          "default": 9.0
        },
        {
          "field": "forcePeriod",
          "description": "Set a value here to force the output period to a fixed value (usually 0.01) to avoid broken HTK files for periods > 0.06s",
          "type": "numeric",
          "default": 0.01
        }
      ]
    },
    {
      "component": "cWaveSink",
      "description": "This component saves data to an uncompressed PCM WAVE file",
      "readsFromLevels": [
        "reader.dmLevel"
      ],
      "baseComponent": "cDataSink",
      "fields": [
        {
          "field": "blocksize_sec",
          "description": "The size of the data blocks to read at once, in seconds",
          "type": "numeric",
          "default": 1.0
        },
        {
          "field": "filename",
          "description": "The filename of the PCM wave file to write data to. Set to '?' to disable this sink component.",
          "type": "string",
          "default": "output.wav",
          "required": true
        },
        {
          "field": "sampleFormat",
          "description": "openSMILE uses float for all data internally. Thus you must specify your desired sample format for the wave files here. Available formats:\n   '8bit' : 8-bit signed \n   '16bit' : 16-bit signed\n   '24bit' : 24-bit signed\n   '24bitp' : 24-bit signed packed in 3 bytes\n   '32bit' : 32-bit signed integer\n   'float' : 32-bit float",
          "type": "string",
          "default": "16bit",
          "allowedValues": [
            "8bit",
            "16bit",
            "24bit",
            "24bitp",
            "32bit",
            "float"
          ]
        },
        {
          "field": "flushData",
          "description": "1/0 (on/off) : flush data to disk and update wave header after writing a frame to the output file (default behaviour is to flush only when the file is closed and openSMILE is being terminated via Ctrl+C or at the end-of-input in offline mode)",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        }
      ]
    },
    {
      "component": "cWaveSinkCut",
      "description": "This component writes data to uncompressed PCM WAVE files. Only chunks, based on timings received via smile messages are written to files. The files may have consecutive numbers appended to the file name.",
      "readsFromLevels": [
        "reader.dmLevel"
      ],
      "baseComponent": "cDataSink",
      "fields": [
        {
          "field": "fileBase",
          "description": "The base of the wave file name, if writing multiple output files (multiOut=1), or else the filename of the wave file to write to",
          "type": "string",
          "default": "output_segment_"
        },
        {
          "field": "fileExtension",
          "description": "The file extension to use when writing multiple output files (multiOut=1), else this option is ignored (the extension is set via 'fileBase' then which specifies the full file name)",
          "type": "string",
          "default": ".wav"
        },
        {
          "field": "fileNameFormatString",
          "description": "Specifies how the filename will be formatted (printf compatible syntax, three parameters are available in the given order: fileBase (string), current index (integer), fileExtension (string)), the default should be reasonable, it generates filenames such as 'output_segment_XXXX.wav'.",
          "type": "string",
          "default": "%s%04d%s"
        },
        {
          "field": "startIndex",
          "description": "The index of the first file for consecutive numbering of output files (if multiOut=1)",
          "type": "numeric",
          "default": 1.0
        },
        {
          "field": "preSil",
          "description": "Specifies the amount of silence at the turn beginning in seconds, i.e. the lag of the turn detector. This is the length of the data that will be added to the current segment prior to the turn start time received in the message from the turn detector component.",
          "type": "numeric",
          "default": 0.2
        },
        {
          "field": "postSil",
          "description": "Specifies the amount of silence at the turn end in seconds. This is the length of the data that will be added to the current segment after to the turn end time received in the message from the turn detector component.",
          "type": "numeric",
          "default": 0.3
        },
        {
          "field": "multiOut",
          "description": "1 = enable multiple file mode, i.e. multiple files segmented by turnStart/turnEnd messages ; 0 = write all frames (only between turnStart/turnEnd messages) concatenated to one file, i.e. effectively filtering out non-turn audio.",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "forceSampleRate",
          "description": "force sample rate to given value (if not set, it is determined from the reader's frame size in bytes, which may be inaccurate)",
          "type": "numeric",
          "default": 16000.0
        },
        {
          "field": "sampleFormat",
          "description": "openSMILE uses float for all data internally. Thus you must specify your desired sample format for the wave files here. Available formats:\n   '8bit' : 8-bit signed \n   '16bit' : 16-bit signed\n   '24bit' : 24-bit signed\n   '24bitp' : 24-bit signed packed in 3 bytes\n   '32bit' : 32-bit signed integer\n   'float' : 32-bit float",
          "type": "string",
          "default": "16bit",
          "allowedValues": [
            "8bit",
            "16bit",
            "24bit",
            "24bitp",
            "32bit",
            "float"
          ]
        },
        {
          "field": "showSegmentTimes",
          "description": "1 = show start and end times relative to input of segments that are saved by this sink.",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "saveSegmentTimes",
          "description": "1 = save turn times (start, end, and filename) to text file.",
          "type": "string",
          "default": null,
          "allowedValues": [
            "0",
            "1"
          ]
        }
      ]
    },
    {
      "component": "cBowProducer",
      "description": "This component produces a bag-of-words vector from the keyword spotter result message.",
      "writesToLevels": [
        "writer.dmLevel"
      ],
      "baseComponent": "cDataSource",
      "fields": [
        {
          "field": "kwList",
          "description": "text file with list of keywords (one word per line) to use for BoW",
          "type": "string",
          "default": null
        },
        {
          "field": "kwListPrefixFilter",
          "description": "keywords in kwList file are expected to have a prefix 'prefix'. Only those keywords will be loaded from the list, everything else will be ignored (i.e. line not beginning with 'prefix').",
          "type": "numeric",
          "default": 0.0
        },
        {
          "field": "prefix",
          "description": "prefix to append to keywords to create feature names",
          "type": "string",
          "default": "BOW_"
        },
        {
          "field": "count",
          "description": "1=count frequency of keyword in input / 0=binary output only (keyword present/not present)",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "textfile",
          "description": "A file that contains sentences (words separated by spaces), which will be converted to BOW vectors. You can use this feature to use this component in offline mode (in online mode the text strings will be received as smile messages).",
          "type": "string",
          "default": null
        },
        {
          "field": "singleSentence",
          "description": "A single sentence to be converted to a BoW vector. Words must be separated by spaces.",
          "type": "string",
          "default": null
        },
        {
          "field": "syncWithAudio",
          "description": "If set to 1, wait for a 'turnFrameTime' message before writing the BoW vector to the output level. This applies only in message-based mode, i.e. this option has no effect if either 'textfile' or 'singleSentence' are used.",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        }
      ]
    },
    {
      "component": "cSignalGenerator",
      "description": "This component provides a signal source. This source generates various noise types and pre-defined signals and value patterns. See the configuration documentation for a list of currently implemented types.",
      "writesToLevels": [
        "writer.dmLevel"
      ],
      "baseComponent": "cDataSource",
      "fields": [
        {
          "field": "nFields",
          "description": "The number of fields in the output vector, set to -1 to use the size of the 'nElements' array or the 'fieldNames' array, if no nElements array is given.",
          "type": "numeric",
          "default": 1.0
        },
        {
          "field": "nElements",
          "description": "An array of number of values/elements for each field in the output vector (default is 1)",
          "type": "numeric",
          "default": 1.0
        },
        {
          "field": "fieldNames",
          "description": "An array of names of fields in the output vector (default for all: noiseN, where N is the field number).",
          "type": "string",
          "default": null
        },
        {
          "field": "signalType",
          "description": "The type of signal/noise to generate for ALL(!) output fields. If you want different types of signals for the individual fields, use multiple noise sources and combine the output vectors in a data reader.\n Currently implemented noise and signal types are:\n   'white' \t white gaussian noise, use parameters 'stddev' and 'mean' to tune.\n   'const' \t constant value output, use 'constant' parameter to set this value.\n   'sine' \t single sine wave (range -1 to +1), see 'signalPeriod' or 'frequency' option and 'phase'.\n   'rect' \t rectangular periodic signal (range -1 to +1), see 'signalPeriod' or 'frequency' option and 'phase'.",
          "type": "string",
          "default": "white",
          "allowedValues": [
            "white",
            "const",
            "sine",
            "rect"
          ]
        },
        {
          "field": "randSeed",
          "description": "Random seed, for pseudo random gaussian white noise",
          "type": "numeric",
          "default": 1.0
        },
        {
          "field": "scale",
          "description": "A scaling factor by which the generated signal is multiplied by",
          "type": "numeric",
          "default": 1.0
        },
        {
          "field": "const",
          "description": "The constant value for the 'constant' signal type",
          "type": "numeric",
          "default": 0.0
        },
        {
          "field": "signalPeriod",
          "description": "The period T in seconds for periodic signals (1.0/frequency). Don't forget to set the sample period via writer.levelconf.T or the 'period' option. Don't confuse this option with the 'period' option!",
          "type": "numeric",
          "default": 1.0
        },
        {
          "field": "frequency",
          "description": "The frequency in Hz of periodic signals (1.0/signalPeriod). This overrides the 'signalPeriod' option, if both are set.",
          "type": "numeric",
          "default": 1.0
        },
        {
          "field": "phase",
          "description": "The initial phase of periodic signals in seconds.",
          "type": "numeric",
          "default": 0.0
        },
        {
          "field": "length",
          "description": "The length of the signal to generate (in seconds), -1.0 for infinite",
          "type": "numeric",
          "default": 3.0
        },
        {
          "field": "lengthFrames",
          "description": "The length of signal to generate (in frames), -1 for infinite (overwrites 'length', if set)",
          "type": "numeric",
          "default": -1.0
        }
      ]
    },
    {
      "component": "cLibsvmLiveSink",
      "description": "This component classifies data from dataMemory 'on-the-fly' using the LibSVM or LibLINEAR library. Loading of ASCII and binary LibSVM models is supported, as well as application of LibSVM scale files and openSMILE feature selection lists.",
      "readsFromLevels": [
        "reader.dmLevel"
      ],
      "sendsMessagesToComponents": [
        "resultRecp"
      ],
      "baseComponent": "cDataSink",
      "fields": [
        {
          "field": "model",
          "description": "LibSVM or LibLINEAR model file(s) to load (see isLibLinearModel option for libLinear).",
          "type": "string",
          "default": "svm.model",
          "required": true
        },
        {
          "field": "isLibLinearModel",
          "description": "1 = load the model(s) as a liblinear model, not libsvm.",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "scale",
          "description": "LibSVM scale file(s) to load",
          "type": "string",
          "default": null
        },
        {
          "field": "fselection",
          "description": "Feature selection file(s) to apply (leave empty to use all features). The feature selection files must contain the exact names of the selected features, one feature per line.",
          "type": "string",
          "default": null
        },
        {
          "field": "nIgnoreEndSelection",
          "description": "number of string lines to ignore at the *end* of the feature selection file (only works for string/name lists, not for index lists!)",
          "type": "numeric",
          "default": 0.0
        },
        {
          "field": "classes",
          "description": "Class name lookup file(s), which map the libsvm class indicies to actual class names (leave empty to display libsvm class numbers/indicies) [note: currently only ONE class name lookup file is supported!]",
          "type": "string",
          "default": null
        },
        {
          "field": "predictProbability",
          "description": "1 = predict class probabilities (confidences) (0 = no)",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "printParseableResult",
          "description": "1 = print easily parsable classification/regression result to stdout",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "printResult",
          "description": "1 = print classification/regression result to log",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "saveResult",
          "description": "filename of text file the result(s) will be saved to",
          "type": "string",
          "default": null
        },
        {
          "field": "saveResultCsv",
          "description": "filename of CSV format file the result(s) will be saved to",
          "type": "string",
          "default": null
        },
        {
          "field": "resultCsvAppend",
          "description": "1 = append to csv result file, 0 = overwrite existing file",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "resultRecp",
          "description": "List of component(s) to send 'classificationResult' messages to (use , to separate multiple recepients), leave blank (NULL) to not send any messages",
          "type": "string",
          "default": null,
          "typeHint": "componentInstance"
        },
        {
          "field": "resultMessageName",
          "description": "Freely definable name that is sent with 'classificationResult' message",
          "type": "string",
          "default": "svm_result"
        },
        {
          "field": "forceScale",
          "description": "1 = for the input values, enforce the range specified in the scale file by clipping out-of-range values (after scaling).",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "lag",
          "description": "read data <lag> frames behind (should always remain 0 for this component...?)",
          "type": "numeric",
          "default": 0.0
        },
        {
          "field": "useThread",
          "description": "1 = load the model and do the classification in a background thread, the data frames (inputs) will be stored in a queue and processed sequentially by the background thread (parallel processing is not implemented yet!).",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "loadModelBg",
          "description": "1 = if useThread==1 (and only then...) load the libsvm model and scale files in the background thread. openSMILE will start to run the tick loop, but classify incoming frames only after the model has been loaded. Up to then all incoming frames are discarded.",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "waitForModelLoaded",
          "description": "1 = if useThread==1 and loadModelBg==1, then wait for the model to be loaded before processing data. If sert to 0, and incoming data while the model is loaded will be discarded (use 0 for real-time operation)",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "threadQueSize",
          "description": "max. number of frames to keep in queue (Set to 0 for an infinite number of frames).",
          "type": "numeric",
          "default": 0.0
        },
        {
          "field": "multiModelMode",
          "description": "1 = classify input data with all loaded models *in parallel* (you will have nModels output messages then). 0 = classify with first model by default. Switching of models is possible via a 'svmSinkSetModel' smile message.",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "batchMode",
          "description": "1 = similar to multiModelMode=1, classify using all models, however only one result message (containing multiple individual results) will be generated.",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "noVerify",
          "description": "1 = *DON'T* verify whether the support vector dimension matches the feature selection list dimension and the scale file dimension.",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "modelResultName",
          "description": "Array of custom names sent as 'custData2' pointer with the classificationResult message for corresponding models. The dimensions of this array should match the dimensions of the 'model' array.",
          "type": "string",
          "default": null
        },
        {
          "field": "bgThreadPriority",
          "description": "The thread priority of the background predictor thread (currently only supported on windows), values -15 (idle) to 15 (real-time), while 0 is normal. This should be lower as or equal to the priority of the openSMILE main thread!",
          "type": "numeric",
          "default": 0.0
        }
      ]
    },
    {
      "component": "cSvmSink",
      "description": "This is an example of a cDataSink descendant. It reads data from the data memory and prints it to the console. This component is intended as a template for developers.",
      "readsFromLevels": [
        "reader.dmLevel"
      ],
      "sendsMessagesToComponents": [
        "resultRecp"
      ],
      "baseComponent": "cDataSink",
      "fields": [
        {
          "field": "model",
          "description": "The name of the model file.",
          "type": "string",
          "default": null
        },
        {
          "field": "printParseableResult",
          "description": "1 = print easily parseable classification/regression result to stdout",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "printResult",
          "description": "1 = print classification/regression result to log",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "saveResult",
          "description": "filename of text file the result(s) will be saved to",
          "type": "string",
          "default": null
        },
        {
          "field": "instanceName",
          "description": "If set, print instance name field to CSV (first column) when saveResult=1, with the given value.",
          "type": "string",
          "default": null
        },
        {
          "field": "append",
          "description": "1 = append to CSV file, in case of saveResult=1, instead of overwriting the file (default).",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "resultRecp",
          "description": "List of component(s) to send 'classificationResult' messages to (use , to separate multiple recepients), leave blank (NULL) to not send any messages",
          "type": "string",
          "default": null,
          "typeHint": "componentInstance"
        },
        {
          "field": "resultMessageName",
          "description": "Freely defineable name that is sent with 'classificationResult' message",
          "type": "string",
          "default": "svm_result"
        },
        {
          "field": "showStatsDebug",
          "description": "1 = show internal values for debugging and sanity checks.",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "ignoreLogitModel",
          "description": "1 = don't use a logistic model for probability estimates, if one is contained in the model.",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "winningClassMethodName",
          "description": "prob = use probabilties instead of votes to determine the winning class, if a logistic model is used. vote = use the standard majority voting based on the distance",
          "type": "string",
          "default": "vote",
          "allowedValues": [
            "prob",
            "vote"
          ]
        }
      ]
    },
    {
      "component": "cRnnSink",
      "description": "This is an example of a cDataSink descendant. It reads data from the data memory and prints it to the console. This component is intended as a template for developers.",
      "readsFromLevels": [
        "reader.dmLevel"
      ],
      "baseComponent": "cDataSink",
      "fields": [
        {
          "field": "netfile",
          "description": "The file which contains the trained network created by rnnlib",
          "type": "string",
          "default": null
        },
        {
          "field": "actoutput",
          "description": "A text file to which the raw output activations will be saved. Each frame will be saved on a separate line (this is rnnlib's activation output format transposed).",
          "type": "string",
          "default": null
        },
        {
          "field": "classoutput",
          "description": "A text file to which the winning class label will be saved (task = classification or transcription). The result for each frame will be saved on a separate line.",
          "type": "string",
          "default": null
        },
        {
          "field": "classlabels",
          "description": "Give a string of comma separated (NO spaces allowed!!) class names (e.g. class1,class2,class3) for a classification or transcription task",
          "type": "string",
          "default": null
        },
        {
          "field": "ctcDecode",
          "description": "1/0 = yes/no : Do basic ctc (transcription) decoding, i.e. remove duplicate labels and (TODO: compute label alignments.)",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "printConnections",
          "description": "1/0 = yes/no : print human readable information on the network layers on connections",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "printInputStats",
          "description": "1/0 = yes/no : print input weight sums (can be used for feature selection...)",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        }
      ]
    },
    {
      "component": "cRnnProcessor",
      "description": "BLSTM RNN processor.",
      "readsFromLevels": [
        "reader.dmLevel"
      ],
      "writesToLevels": [
        "writer.dmLevel"
      ],
      "baseComponent": "cDataProcessor",
      "fields": [
        {
          "field": "netfile",
          "description": "The file which contains the trained network created by rnnlib",
          "type": "string",
          "default": null
        },
        {
          "field": "jsonNet",
          "description": "1/0 = yes/no. Flag that indicates whether 'netfile' is in json format (1) (trained with current) or in rnnlib format (0).",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "classlabels",
          "description": "Give a string of comma separated (NO spaces allowed!!) class names (e.g. class1,class2,class3) for a classification or transcription task",
          "type": "string",
          "default": null
        },
        {
          "field": "printConnections",
          "description": "1/0 = yes/no : print human readable information on the network layers on connections",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        }
      ]
    },
    {
      "component": "cRnnVad2",
      "description": "BLSTM RNN processor.",
      "readsFromLevels": [
        "reader.dmLevel"
      ],
      "writesToLevels": [
        "writer.dmLevel"
      ],
      "baseComponent": "cDataProcessor",
      "fields": [
        {
          "field": "voiceIdx",
          "description": "The index of the field which contains the 'voice' class output activation. (0 is the first field)",
          "type": "numeric",
          "default": 0.0
        },
        {
          "field": "agentIdx",
          "description": "The index of the field which contains the 'agent/alien' class output activation. (0 is the first field)",
          "type": "numeric",
          "default": 1.0
        },
        {
          "field": "voiceThresh",
          "description": "The threshold to apply to the 'voice' output activation.",
          "type": "numeric",
          "default": 0.4
        },
        {
          "field": "agentThresh",
          "description": "The threshold to apply to the 'agent' output activation.",
          "type": "numeric",
          "default": 0.3
        },
        {
          "field": "energyIdx",
          "description": "The index of the field which contains the energy/loudness/intensity/etc. value (set to -1 to disable)",
          "type": "numeric",
          "default": 2.0
        },
        {
          "field": "f0Idx",
          "description": "Index of F0 input field (set to -1 to disable)",
          "type": "numeric",
          "default": 3.0
        },
        {
          "field": "agentTurnPastBlock",
          "description": "time the VAD will be blocked after receiving an agent speech end message (in frames, usually 100fps) (use 20 for the SEMAINE speech2speech system, and 60 for the speech2face system).",
          "type": "numeric",
          "default": 20.0
        },
        {
          "field": "alwaysRejectAgent",
          "description": "1 = never detect a speaker turn while the agent is speaking",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "smartRejectAgent",
          "description": "1 = apply different VAD strategy while agent is speaking",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "userEavgHold",
          "description": "Hold time for user energy envelope and average computation (10ms frames as unit).",
          "type": "numeric",
          "default": 500.0
        },
        {
          "field": "userEavgDecay",
          "description": "Decay (linear) time for user energy envelope and average computation (10ms frames as unit).",
          "type": "numeric",
          "default": 500.0
        },
        {
          "field": "agentEavgHold",
          "description": "Hold time for user energy envelope and average computation (10ms frames as unit).",
          "type": "numeric",
          "default": 200.0
        },
        {
          "field": "agentEavgDecay",
          "description": "Decay (linear) time for user energy envelope and average computation (10ms frames as unit).",
          "type": "numeric",
          "default": 200.0
        },
        {
          "field": "vadDebug",
          "description": "1 = output energy and VAD statistics for debugging (set to 2 to always force vad output value to 0 while debugging).",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "allowEoverride",
          "description": "1 = allow VAD output even if LSTM does not detect voice when the energy is in the range of the user's current energy envelope (NOTE: this reduces noise robustness, e.g. when moving a headset etc.)",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        }
      ]
    },
    {
      "component": "cMonoMixdown",
      "description": "This is a simple mixer, which adds multiple channels (elements) to a single channel (element).",
      "readsFromLevels": [
        "reader.dmLevel"
      ],
      "writesToLevels": [
        "writer.dmLevel"
      ],
      "baseComponent": "cDataProcessor",
      "fields": [
        {
          "field": "normalise",
          "description": "1/0 = yes/no : divide by the number of channels when adding samples from multiple channels.",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "bufsize",
          "description": "number of samples to process at once. Choose a number >> 1 for optimal performance. Too large buffer sizes may influence the latency!",
          "type": "numeric",
          "default": 1024.0
        }
      ]
    },
    {
      "component": "cTransformFFT",
      "description": "This component performs an FFT on a sequence of real values (one frame), the output is the complex domain result of the transform. Use the cFFTmagphase component to compute magnitudes and phases from the complex output.",
      "readsFromLevels": [
        "reader.dmLevel"
      ],
      "writesToLevels": [
        "writer.dmLevel"
      ],
      "baseComponent": "cVectorProcessor",
      "fields": [
        {
          "field": "inverse",
          "description": "1 = perform inverse real FFT",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "zeroPadSymmetric",
          "description": "1 = zero pad symmetric (when zero padding to next power of 2), i.e. center frame and pad left and right with zeros. New since version 2.3: this is the default, but should not affect FFT magnitudes at all, only phase.",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        }
      ]
    },
    {
      "component": "cFFTmagphase",
      "description": "This component computes magnitude and phase of each array in the input level (it thereby assumes that the arrays contain complex numbers with real and imaginary parts alternating, as computed by the cTransformFFT component).",
      "readsFromLevels": [
        "reader.dmLevel"
      ],
      "writesToLevels": [
        "writer.dmLevel"
      ],
      "baseComponent": "cVectorProcessor",
      "fields": [
        {
          "field": "inverse",
          "description": "If set to 1, converts magnitude and phase input data to complex frequency domain data",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "magnitude",
          "description": "1/0 = compute magnitude yes/no (or use magnitude as input to inverse transformation, must be enabled for inverse)",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "phase",
          "description": "1/0 = compute phase yes/no (or use phase as input to inverse transformation, must be enabled for inverse)",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "joinMagphase",
          "description": "Output magnitude and phase information to a single array field (instead of creating two array fields, one for magnitude and one for phase information). The first half contains magnitude values, the second half phase values.",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "normalise",
          "description": "1/0 = yes/no: normalise FFT magnitudes to input window length, to obtain spectral densities.",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "power",
          "description": "1/0 = yes/no: square FFT magnitudes to obtain power spectrum.",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "dBpsd",
          "description": "1/0 = yes/no: output logarithmic (dB SPL) power spectral density instead of linear magnitude spectrum (you should use a Hann window for analysis in this case). Setting this option also sets/implies 'normalise=1' and 'power=1'",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "dBpnorm",
          "description": "Value for dB power normalisation when 'dBpsd=1' (in dB SPL). Default is according to MPEG-1, psy I model.",
          "type": "numeric",
          "default": 90.302
        },
        {
          "field": "mindBp",
          "description": "Minimum dB power value for flooring when using dBpsd. (mindBp >= dBpnorm - 120.0) will be enforced, so mindBp might be higher than set here, depending on dBpnorm parameter.",
          "type": "numeric",
          "default": -102.0
        }
      ]
    },
    {
      "component": "cAmdf",
      "description": "This component computes the Average Magnitude Difference Function (AMDF) for each input frame. Various methods for padding or warping at the border exist.",
      "readsFromLevels": [
        "reader.dmLevel"
      ],
      "writesToLevels": [
        "writer.dmLevel"
      ],
      "baseComponent": "cVectorProcessor",
      "fields": [
        {
          "field": "nameAppend",
          "description": "A string suffix to append to the input field names (default: empty)",
          "type": "string",
          "default": "amdf"
        },
        {
          "field": "nLag",
          "description": "If nLag > 0, compute AMDF up to maximum lag 'nLag' (or maximum possible lag limited by framesize). If nLag=0, then always the maximum framesize will be used (this is the default). If nLag < 0, then nLag=framesize/((-1)*nLag) will be used.",
          "type": "numeric",
          "default": 0.0
        },
        {
          "field": "method",
          "description": "The AMDF computation method (i.e. the handling of border conditions):\n    'limit' :  compute AMDF only in regions where the shifted windows overlap\n    'warp' : compute cyclical AMDF by warping of input\n    'zeropad' : zero pad missing samples",
          "type": "string",
          "default": "limit",
          "allowedValues": [
            "limit",
            "warp",
            "zeropad"
          ]
        },
        {
          "field": "invert",
          "description": "1 = invert the AMDF output values (literally '1-amdf'), i.e. so that the behaviour of the AMDF output corresponds more to that of an autocorrelation function.",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        }
      ]
    },
    {
      "component": "cAcf",
      "description": "This component computes the autocorrelation function (ACF) by squaring a magnitude spectrum and applying an inverse Fast Fourier Transform. This component must read from a level containing *only* FFT magnitudes in a single field. Use the 'cTransformFFT' and 'cFFTmagphase' components to compute the magnitude spectrum from PCM frames. Computation of the Cepstrum is also supported (this applies a log() function to the magnitude spectra).",
      "readsFromLevels": [
        "reader.dmLevel"
      ],
      "writesToLevels": [
        "writer.dmLevel"
      ],
      "baseComponent": "cVectorProcessor",
      "fields": [
        {
          "field": "nameAppend",
          "description": "A string suffix to append to the input field names (default: empty)",
          "type": "string",
          "default": "acf"
        },
        {
          "field": "usePower",
          "description": "1 = square input values; you must leave this at default 1, when using fft magnitude as input for ACF. For cepstrum this will be set to 0 by default, unless you explicitly give the value 1.",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "cepstrum",
          "description": "1 = compute the real valued cepstrum instead of the standard ACF. This applies a log() to the magnitudes bevore transforming from the spectral domain back to the time domain. You might want to set 'nameAppend=cepstrum' when using this option. See the cCepstrum component for complex valued cepstrum and more options (only in commercial version).",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "inverse",
          "description": "1 = do the inverse transform of cepstrum or ACF. The output is an FFT magnitude spectrum.",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "cosLifterCepstrum",
          "description": "1 = apply cosine lifter function to the cepstrum, effectively applying a Hanning window function to the cepstrum.",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "expBeforeAbs",
          "description": "1 = perform exp operation before computing magnitude spectrum (for inverse cepstrum only).",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "symmetricData",
          "description": "1 = treat data in acf/cepstral domain as symmetric data, i.e. output only half of the buffer or symmetrically duplicate the input before applying fft.",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "acfCepsNormOutput",
          "description": "1 = Divide the output values by the framesize (this is the default since version 2.0, however for older versions, such as 0.1 (openEAR) setting this option to 0 is required for comaptibility.",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "oldCompatCepstrum",
          "description": "1 = compatibility with old openEAR (0.1) cepstrum computation (absCepstrum = 1, acfCepsNormOutput = 0, and usePower should be 1 (not forced though)).",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ],
          "recommendedValue": 0.0
        },
        {
          "field": "absCepstrum",
          "description": "1 = enable output of root of power cepstrum (absolute value)",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        }
      ]
    },
    {
      "component": "cPreemphasis",
      "description": "This component performs pre- and de-emphasis of speech signals using a 1st order difference equation: y(t) = x(t) - k*x(t-1)  (de-emphasis: y(t) = x(t) + k*x(t-1))",
      "readsFromLevels": [
        "reader.dmLevel"
      ],
      "writesToLevels": [
        "writer.dmLevel"
      ],
      "baseComponent": "cWindowProcessor",
      "fields": [
        {
          "field": "k",
          "description": "The pre-emphasis coefficient k in y[n] = x[n] - k*x[n-1]",
          "type": "numeric",
          "default": 0.97
        },
        {
          "field": "f",
          "description": "The pre-emphasis frequency f in Hz : k = exp( -2*pi * f/samplingFreq. ) (if set, f will override k!)",
          "type": "numeric",
          "default": 0.0
        },
        {
          "field": "de",
          "description": "1 = perform de-emphasis instead of pre-emphasis (i.e. y[n] = x[n] + k*x[n-1])",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        }
      ]
    },
    {
      "component": "cVectorPreemphasis",
      "description": "This component performs per frame pre-emphasis without an inter-frame state memory. (This is the way HTK does pre-emphasis). Pre-emphasis: y(t) = x(t) - k*x(t-1) ; de-emphasis : y(t) = x(t) + k*x(t-1)",
      "readsFromLevels": [
        "reader.dmLevel"
      ],
      "writesToLevels": [
        "writer.dmLevel"
      ],
      "baseComponent": "cVectorProcessor",
      "fields": [
        {
          "field": "k",
          "description": "The pre-emphasis coefficient k in y[n] = x[n] - k*x[n-1]",
          "type": "numeric",
          "default": 0.97
        },
        {
          "field": "f",
          "description": "The pre-emphasis frequency f in Hz : k = exp( -2*pi * f/samplingFreq. ) (this option will override k)",
          "type": "numeric",
          "default": 0.0
        },
        {
          "field": "de",
          "description": "1 = perform de- instead of pre-emphasis",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        }
      ]
    },
    {
      "component": "cVectorMVN",
      "description": "This component extends the base class cVectorTransform and implements mean/variance normalisation. You can use this component to perform on-line cepstral mean normalisation. See cFullinputMean for off-line cepstral mean normalisation.",
      "readsFromLevels": [
        "reader.dmLevel"
      ],
      "writesToLevels": [
        "writer.dmLevel"
      ],
      "baseComponent": "cVectorTransform",
      "fields": [
        {
          "field": "nameAppend",
          "description": "A string suffix to append to the input field names (default: empty)",
          "type": "string",
          "default": null
        },
        {
          "field": "meanEnable",
          "description": "1 = enable normalisation to 0 mean",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "stdEnable",
          "description": "1 = enable standardisation to stddev 1",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "normEnable",
          "description": "1 = enable normalisation (scaling) to range -1 to +1, if meanEnable=1 (x-mean)/((max-min)*0.5), or to range 0..1 if meanEnable=0  (x-min)/(max-min) ; (this can NOT be used in conjunction with stdEnable)",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "minMaxNormEnable",
          "description": "1 = enable normalisation (scaling) to range -1 to +1 with only min and max values: x=2*(x-min)/(max-min)-1",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "spectralFlooring",
          "description": "1 = enable spectral subtraction by flooring all spectral bins below the mean (to the value of 'specFloor') and not touching bins above the mean (except if you set subtractMeans=1). (works only if meanEnable=1 is the only normalisation option set)",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "subtractMeans",
          "description": "(only relevant if spectralFlooring=1) : 1 = if input values are above the mean, subtract the mean (else floor to 'specFloor').",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "specFloor",
          "description": "The value to which bins will be set that are floored.",
          "type": "numeric",
          "default": 1e-10
        },
        {
          "field": "htkLogEnorm",
          "description": "1 = enable HTK compatible log energy normalisation (this also sets normEnable=1, meanEnable=0)",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        }
      ]
    },
    {
      "component": "cTurnDetector",
      "description": "Speaker turn detector using data from cVadV1 component or cSemaineSpeakerID1 (adaptive VAD) to determine speaker turns and identify continuous segments of voice activity.",
      "readsFromLevels": [
        "reader.dmLevel"
      ],
      "writesToLevels": [
        "writer.dmLevel"
      ],
      "sendsMessagesToComponents": [
        "messageRecp",
        "eventRecp",
        "statusRecp"
      ],
      "baseComponent": "cDataProcessor",
      "fields": [
        {
          "field": "threshold",
          "description": "The silence->speech threshold to use (the default value is for RMS energy, change it to -13.0 for log energy)",
          "type": "numeric",
          "default": 0.001
        },
        {
          "field": "threshold2",
          "description": "The speech->silence threshold to use (if this value is not set in the config, the same value as 'threshold' will be used)",
          "type": "numeric",
          "default": 0.001
        },
        {
          "field": "autoThreshold",
          "description": "1 = automatically adjust threshold for RMS energy (EXPERIMENTAL; works for energy as input)",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "minmaxDecay",
          "description": "The decay constant used for min/max values in auto-thresholder (a larger value means a slower recovery from loud sounds)",
          "type": "numeric",
          "default": 0.9995
        },
        {
          "field": "nPre",
          "description": "number of frames > threshold until a turn start is detected",
          "type": "numeric",
          "default": 10.0
        },
        {
          "field": "nPost",
          "description": "number of frames < threshold(2) until a turn end is detected",
          "type": "numeric",
          "default": 20.0
        },
        {
          "field": "useRMS",
          "description": "1 = the provided energy field in the input is rms energy instead of log energy",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "readVad",
          "description": "1 = use the result (bianry 0/1 or probability) from another VAD component instead of reading RMS or LOG energy ('threshold' and 'threshold2' will be set to 0.55 and 0.45 if this option is enabled, unless other values for thresholds are given in the config file)",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "idx",
          "description": "The index of the RMS or LOG energy (or vadBin) field to use (-1 to automatically find the field)",
          "type": "numeric",
          "default": -1.0
        },
        {
          "field": "messageRecp",
          "description": "The (cWinToVecProcessor type) component(s) to send 'frameTime' messages to (use , to separate multiple recepients), leave blank (NULL) to not send any messages. The messages will be sent at the turn end and (optionally) during the turn at fixed intervals configured by the 'msgInterval' parameter (if it is not 0).",
          "type": "string",
          "default": null,
          "typeHint": "componentInstance,"
        },
        {
          "field": "msgInterval",
          "description": "Interval at which to send 'frameTime' messages during an ongoing turn. Set to 0 to disable sending of intra turn messages.",
          "type": "numeric",
          "default": 0.0
        },
        {
          "field": "turnFrameTimePreRollSec",
          "description": "Time offset which is added to the turnStart for turnFrameTimeMessages. Use this to compensate for VAD lags. Typically one would use negative values here, e.g. -0.1.",
          "type": "numeric",
          "default": 0.0
        },
        {
          "field": "turnFrameTimePostRollSec",
          "description": "Time offset which is added to the turnEnd for turnFrameTimeMessages. Use this to compensate for VAD lags. CAUTION: If this value is positive, it might prevent the receiving component from working correctly, as it will not have all data (for the full segment) available in the input data memory level when it receives the message.",
          "type": "numeric",
          "default": 0.0
        },
        {
          "field": "msgPeriodicMaxLength",
          "description": "If periodic message sending is enabled (msgInterval > 0), then this can limit the maximum length of the segments (going backwards from the current position, i.e. a sliding window - as opposed to maxTurnLength, which limits the total turn length from the beginning of the turn). If this is 0, there is no limit (= default), the segments will grow up to maxTurnLength.",
          "type": "numeric",
          "default": 0.0
        },
        {
          "field": "sendTurnFrameTimeMessageAtEnd",
          "description": "If not 0, indicates that at the end of a turn a turnFrameTime message will be sent. If it is set to 1, a full length (from turn start to turn end) message will be sent. If it is set to 2, and if periodic sending is enabled (msgInterval > 0) and msgPeriodicMaxLength is set (> 0), then only a message of msgPeriodicMaxLength (from turn end backwards) will be sent. Leave this option at the default of 1 if not using periodic message sending (msgInterval > 0).",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "eventRecp",
          "description": "The component(s) to send 'turnStart/turnEnd' messages to (use , to separate multiple recepients), leave blank (NULL) to not send any messages",
          "type": "string",
          "default": null,
          "typeHint": "componentInstance,"
        },
        {
          "field": "statusRecp",
          "description": "The component(s) to send 'turnSpeakingStatus' messages to (use , to separate multiple recepients), leave blank (NULL) to not send any messages",
          "type": "string",
          "default": null,
          "typeHint": "componentInstance,"
        },
        {
          "field": "minTurnLengthTurnFrameTimeMessage",
          "description": "The minimum turn length in seconds (<= 0 : infinite) for turnFrameTime messages. No Message will be sent if the detected turn is shorter than the given value. turnStart and turnEnd messages will still be sent though.",
          "type": "numeric",
          "default": 0.0
        },
        {
          "field": "minTurnLength",
          "description": "[NOT YET IMPLEMENTED!] The minimum turn length in seconds (<= 0 : infinite) for turnFrameTime and turnStart messages. No Message will be sent if the detected turn is shorter than the given value. IMPORTANT: This introduces a lag of the given minimum length for turn start messages!",
          "type": "numeric",
          "default": 0.0
        },
        {
          "field": "maxTurnLength",
          "description": "The maximum turn length in seconds (<= 0 : infinite). A turn end will be favoured by reducing nPost to 1 after this time",
          "type": "numeric",
          "default": 0.0
        },
        {
          "field": "maxTurnLengthGrace",
          "description": "The grace period to grant, after maxTurnLength is reached (in seconds). After a turn length of maxTurnLength + maxTurnLengthGrace an immediate turn end will be forced.",
          "type": "numeric",
          "default": 1.0
        },
        {
          "field": "invert",
          "description": "Invert the behaviour of turnStart/turnEnd messages. Also send a turnStart message at vIdx = 0, and a turnEnd message at the end (EOI).",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "debug",
          "description": "log level to show some turn detector specific debug messages on",
          "type": "numeric",
          "default": 4.0
        },
        {
          "field": "timeoutSec",
          "description": "turnEnd timeout in seconds (send turnEnd after timeoutSec seconds no input data)",
          "type": "numeric",
          "default": 2.0
        },
        {
          "field": "eoiFramesMissing",
          "description": "set the number of frames that will be subtracted from the last turn end position (the forced turn end that will be sent when an EOI condition (end of input) is encountered). This is necessary, e.g. if you use delta or acceleration coefficients which introduce a lag of a few frames. Increase this value if SMILExtract hangs at the end of input when using the cTumkwsjSink component or a cFunctionals component, etc.",
          "type": "numeric",
          "default": 5.0
        },
        {
          "field": "unblockTimeout",
          "description": "timeout in frames to wait after a turn block condition (started via a semaineCallback message)",
          "type": "numeric",
          "default": 60.0
        },
        {
          "field": "blockStatus",
          "description": "apply event based speech detection block  for speakingStatus messages (i.e.  the sending of these messages is supressed)",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "blockAll",
          "description": "apply event based speech detection block for all types, i.e. the voice input is set to 0 by an incoming block message.",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "terminateAfterTurns",
          "description": "Number of turns after which to terminate processing and exit openSMILE. Default 0 is for infinite, i.e. never terminate.",
          "type": "numeric",
          "default": 0.0
        },
        {
          "field": "terminatePostSil",
          "description": "Amount of silence after last turn of terminateAfterTurns to wait for before actually exiting. This excludes (i.e. is on top of) postSil which is required to detect the end of the turn.",
          "type": "numeric",
          "default": 0.0
        },
        {
          "field": "initialBlockTime",
          "description": "Initial time (in seconds) to block VAD (useful in conjunction with RNN vad, or if high noise occurrs after starting VAD.",
          "type": "numeric",
          "default": 1.0
        },
        {
          "field": "loadSegmentsFromFile",
          "description": "If set to a filename, load the segment times from this CSV file (; as separator/ header line/ columns 'Start' and 'End' required, others are ignored. The input level data is then ignored, only the frame timestamps are used to sync and send messages based on the file timestamps. Not really suitable for live mode (although it works, but no sense in using pre-defined timestamps...)!",
          "type": "string",
          "default": null
        }
      ]
    },
    {
      "component": "cDeltaRegression",
      "description": "This component computes delta regression coefficients using the regression equation from the HTK book.",
      "readsFromLevels": [
        "reader.dmLevel"
      ],
      "writesToLevels": [
        "writer.dmLevel"
      ],
      "baseComponent": "cWindowProcessor",
      "fields": [
        {
          "field": "blocksize",
          "description": "The size of data blocks to process in frames (this sets both blocksizeR and blocksizeW, and overwrites blocksize_sec)",
          "type": "numeric",
          "default": 1.0
        },
        {
          "field": "nameAppend",
          "description": "A string suffix to append to the input field names (default: empty)",
          "type": "string",
          "default": "de"
        },
        {
          "field": "deltawin",
          "description": "Specifies the size of half of the delta regression window (If set to 0, a simple difference x[n]-x[n-1] will be computed)",
          "type": "numeric",
          "default": 2.0
        },
        {
          "field": "absOutput",
          "description": "1/0 = on/off : Output absolute value of delta regression or difference function (i.e. do full wave rectification on output signal).",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "halfWaveRect",
          "description": "1/0 = on/off : Do half-wave rectification on output values (i.e. keep only positive values and set negative values to 0). Please note that 'halfWaveRect' overrides the 'absOutput' option.",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "onlyInSegments",
          "description": "1/0 = on/off : Don't compute deltas at segment boundaries. Segments are bounded by one or more NaN values, or zeros, if zeroSegBound=1 (default)",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "zeroSegBound",
          "description": "1/0 = on/off : Consider zeros as segment boundaries (in conjunction with onlyInSegments option).",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "relativeDelta",
          "description": "1/0 = on/off : Compute relative deltas, instead of standard deltas: delta[n] = (x[n] - x[n-1]) / |x[n-1]| if x[n-1] != 0 else delta[n] = 0",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        }
      ]
    },
    {
      "component": "cContourSmoother",
      "description": "This component smooths data contours by applying a moving average filter of configurable length.",
      "readsFromLevels": [
        "reader.dmLevel"
      ],
      "writesToLevels": [
        "writer.dmLevel"
      ],
      "baseComponent": "cWindowProcessor",
      "fields": [
        {
          "field": "blocksize",
          "description": "The size of data blocks to process in frames (this sets both blocksizeR and blocksizeW, and overwrites blocksize_sec)",
          "type": "numeric",
          "default": 1.0
        },
        {
          "field": "nameAppend",
          "description": "A string suffix to append to the input field names (default: empty)",
          "type": "string",
          "default": "sma"
        },
        {
          "field": "smaWin",
          "description": "The size of the moving average window. A larger window means more smoothing.",
          "type": "numeric",
          "default": 3.0
        },
        {
          "field": "noZeroSma",
          "description": "1 = exclude frames where the element value is 0 from smoothing (i.e. 0 input will be 0 output, and zeros around non-zero values will not be included in the computation of the running average).",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        }
      ]
    },
    {
      "component": "cSmileResample",
      "description": "This component implements a spectral domain resampling component. Input frames are transferred to the spectral domain, then the spectra are shifted, and a modified DFT is performed to synthesize samples at the new rate.",
      "readsFromLevels": [
        "reader.dmLevel"
      ],
      "writesToLevels": [
        "writer.dmLevel"
      ],
      "baseComponent": "cDataProcessor",
      "fields": [
        {
          "field": "blocksize",
          "description": "The size of data blocks to process in frames (this sets both blocksizeR and blocksizeW, and overwrites blocksize_sec)",
          "type": "numeric",
          "default": 0.0
        },
        {
          "field": "blocksizeR",
          "description": "The size of data blocks to read in frames (overwrites blocksize)",
          "type": "numeric",
          "default": 0.0
        },
        {
          "field": "blocksizeW",
          "description": "The size of data blocks to write in frames (overwrites blocksize)",
          "type": "numeric",
          "default": 0.0
        },
        {
          "field": "targetRate",
          "description": "The target sampling frequency in Hz",
          "type": "numeric",
          "default": 16000.0
        },
        {
          "field": "resampleRatio",
          "description": "A fixed resample ratio a (a=fsNew/fsCurrent). If set, this overrides targetFs",
          "type": "numeric",
          "default": 1.0
        },
        {
          "field": "pitchRatio",
          "description": "Low-quality pitch scaling factor, if != 1.0",
          "type": "numeric",
          "default": 1.0
        },
        {
          "field": "useQuickAlgo",
          "description": "Use a quick algo for low-quality integer-ratio DOWN(!)sampling.",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "winSize",
          "description": "Internal window size in seconds (will be rounded to nearest power of 2 framesize internally). This affects the quality of the resampling and the accuracy of the target sampling rate. Larger window sizes allow for a more accurate target sampling frequency, i.e. less pitch distortion.",
          "type": "numeric",
          "default": 0.03
        }
      ]
    },
    {
      "component": "cSpecResample",
      "description": "This component implements a spectral domain resampling component. Input frames are complex valued spectral domain data, which will be shifted and scaled by this component, and a modified DFT is performed to synthesize samples at the new rate.",
      "readsFromLevels": [
        "reader.dmLevel"
      ],
      "writesToLevels": [
        "writer.dmLevel"
      ],
      "baseComponent": "cVectorProcessor",
      "fields": [
        {
          "field": "processArrayFields",
          "description": "1 = process each array field as one vector individually (and produce one output for each input array field). Only array fields (i.e. fields with more than one element) are processed if this is set. / 0 = process complete input frame as one vector, ignoring field/element structure",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "targetFs",
          "description": "The target sampling frequency in Hz",
          "type": "numeric",
          "default": 16000.0
        },
        {
          "field": "resampleRatio",
          "description": "Specifies a fixed resample ratio a (a=fsNew/fsCurrent). If set, this overrides targetFs",
          "type": "numeric",
          "default": 1.0
        },
        {
          "field": "inputFieldPartial",
          "description": "The name of the input field to search for. (NULL (default): use full input vector)",
          "type": "string",
          "default": null
        }
      ]
    },
    {
      "component": "cDbA",
      "description": "This component performs dbX (dbA,dbB,dbC,...) equal loudness weighting of FFT bin magnitudes. Currently only dbA weighting is implemented.",
      "readsFromLevels": [
        "reader.dmLevel"
      ],
      "writesToLevels": [
        "writer.dmLevel"
      ],
      "baseComponent": "cVectorProcessor",
      "fields": [
        {
          "field": "curve",
          "description": "1 character, which specifies the type of the curve to use (supported: A ; soon supported: B,C) [NOT YET FULLY IMPLEMENTED, ONLY A is supported]",
          "type": "char",
          "default": "A",
          "allowedValues": [
            "A",
            "B",
            "C"
          ]
        },
        {
          "field": "usePower",
          "description": "1 = square the input magnitudes before multiplying with the dX weighting function (the output will then be a dBX weighted power spectrum)",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        }
      ]
    },
    {
      "component": "cVadV1",
      "description": "A voice activity detector based on Line-Spectral-Frequencies, Mel spectra and energy + smoothing. This component requires input of the following type in the following order: MelSpec;lsf;energy. See vadV1.hpp for an example config!",
      "readsFromLevels": [
        "reader.dmLevel"
      ],
      "writesToLevels": [
        "writer.dmLevel"
      ],
      "baseComponent": "cDataProcessor",
      "fields": [
        {
          "field": "threshold",
          "description": "The minimum rms/log energy threshold to use (or the actual rms energy threshold, if disableDynamicVAD==1)",
          "type": "numeric",
          "default": -13.0
        },
        {
          "field": "disableDynamicVAD",
          "description": "1/0 = yes/no, whether dynamic VAD is disabled (default is enabled)",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "debug",
          "description": "1/0 enable/disable vad debug output",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        }
      ]
    },
    {
      "component": "cSpecScale",
      "description": "This component performs linear/non-linear axis scaling of FFT magnitude spectra with spline interpolation.",
      "readsFromLevels": [
        "reader.dmLevel"
      ],
      "writesToLevels": [
        "writer.dmLevel"
      ],
      "baseComponent": "cVectorProcessor",
      "fields": [
        {
          "field": "processArrayFields",
          "description": "1 = process each array field as one vector individually (and produce one output for each input array field). Only array fields (i.e. fields with more than one element) are processed if this is set. / 0 = process complete input frame as one vector, ignoring field/element structure",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "scale",
          "description": "The target scale, one of the following:\n   'log(arithmic)' (logarithmic, see 'logScaleBase')\n   'oct(ave)' (octave scale = logarithmic with base 2)\n   'sem(itone)' (musical semi-tone scale)\n   'lin(ear)' (linear scale)\n   'bar(k)' (bark scale)\n   'bao' (old - pre 2.0 - approximation of bark scale)\n   'mel' (mel frequency scale)",
          "type": "string",
          "default": "log",
          "allowedValues": [
            "log",
            "logarithmic",
            "oct",
            "octave",
            "sem",
            "semitone",
            "lin",
            "linear",
            "bar",
            "bark",
            "bao",
            "mel"
          ]
        },
        {
          "field": "sourceScale",
          "description": "The source scale (currently only 'lin(ear)' is supported, all other options (as found for target scale) are experimental)",
          "type": "string",
          "default": "lin",
          "allowedValues": [
            "log",
            "logarithmic",
            "oct",
            "octave",
            "sem",
            "semitone",
            "lin",
            "linear",
            "bar",
            "bark",
            "bao",
            "mel"
          ]
        },
        {
          "field": "logScaleBase",
          "description": "The base for log scales (a log base of 2.0 - the default - corresponds to an octave target scale)",
          "type": "numeric",
          "default": 2.0
        },
        {
          "field": "logSourceScaleBase",
          "description": "The base for log source scales (a log base of 2.0 - the default - corresponds to an octave target scale)",
          "type": "numeric",
          "default": 2.0
        },
        {
          "field": "firstNote",
          "description": "The first note (in Hz) for a semi-tone scale",
          "type": "numeric",
          "default": 55.0
        },
        {
          "field": "interpMethod",
          "description": "The interpolation method for rescaled spectra: 'none', 'spline'",
          "type": "string",
          "default": "spline",
          "allowedValues": [
            "none",
            "spline"
          ]
        },
        {
          "field": "minF",
          "description": "The minimum frequency of the target scale",
          "type": "numeric",
          "default": 25.0
        },
        {
          "field": "maxF",
          "description": "The maximum frequency of the target scale (-1.0 : set to maximum frequency of the source spectrum)",
          "type": "numeric",
          "default": -1.0
        },
        {
          "field": "nPointsTarget",
          "description": "The number of frequency points in target spectrum (<= 0 : same as input spectrum)",
          "type": "numeric",
          "default": 0.0
        },
        {
          "field": "specSmooth",
          "description": "1 = perform spectral smoothing before applying the scale transformation",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "specEnhance",
          "description": "1 = do spectral peak enhancement before applying smoothing (if enabled) and scale transformation",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "auditoryWeighting",
          "description": "1 = enable post-scale auditory weighting (this is currently only supported for octave (log2) scales)",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        }
      ]
    },
    {
      "component": "cMZcr",
      "description": "This component computes time signal properties, zero-corssing rate, mean-crossing rate, dc offset, max/min value, and absolute maximum value of a PCM frame.",
      "readsFromLevels": [
        "reader.dmLevel"
      ],
      "writesToLevels": [
        "writer.dmLevel"
      ],
      "baseComponent": "cVectorProcessor",
      "fields": [
        {
          "field": "nameAppend",
          "description": "(ignored here)",
          "type": "string",
          "default": null
        },
        {
          "field": "zcr",
          "description": "(1/0=yes/no) compute zero-crossing rate (zcr)",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "mcr",
          "description": "(1/0=yes/no) compute mean-crossing rate (mcr) (i.e. the rate at which a signal crosses its mean, for signals with mean 0 this is identical to the zero-crossing rate)",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "amax",
          "description": "(1/0=yes/no) enable output of the maximum *absolute* sample value",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "maxmin",
          "description": "(1/0=yes/no) enable output of the maximum and minimum sample value",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "dc",
          "description": "(1/0=yes/no) compute the DC-offset (= the arithmetic mean of input values)",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        }
      ]
    },
    {
      "component": "cEnergy",
      "description": "This component computes logarithmic (log) and root-mean-square (rms) signal energy from PCM frames.",
      "readsFromLevels": [
        "reader.dmLevel"
      ],
      "writesToLevels": [
        "writer.dmLevel"
      ],
      "baseComponent": "cVectorProcessor",
      "fields": [
        {
          "field": "nameAppend",
          "description": "A string suffix to append to the input field names (default: empty)",
          "type": "string",
          "default": "energy"
        },
        {
          "field": "processArrayFields",
          "description": "1 = process each array field as one vector individually (and produce one output for each input array field). Only array fields (i.e. fields with more than one element) are processed if this is set. / 0 = process complete input frame as one vector, ignoring field/element structure",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "htkcompatible",
          "description": "If set to 1, enable htk compatible log-energy output (this will output log-energy ONLY! no rms energy...)",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "rms",
          "description": "1/0 = on/off   output of root-mean-square (RMS) energy ( = square root of ( the sum over all input values n=0...N of (x[n]*x[n]) divided by N)",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "energy2",
          "description": "1/0 = on/off   output of quadratic energy (sum of all x[n]^2  divided by N)",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "log",
          "description": "1/0 = on/off   output logarithmic energy (log-energy). E = log( sum (x[n]*x[n]/N ) ; The argument of the log() function is floored to 8.674676e-019. The output unit has the unit of 'neper' (which is simlar to decibel, with the only difference that the natural logarithm (base e) is used instead of the base-10 logarithm)",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "escaleLog",
          "description": "scale factor to multiply log energy by",
          "type": "numeric",
          "default": 1.0
        },
        {
          "field": "escaleRms",
          "description": "scale factor to multiply rms energy by",
          "type": "numeric",
          "default": 1.0
        },
        {
          "field": "escaleSquare",
          "description": "scale factor to multiply quadratic energy by",
          "type": "numeric",
          "default": 1.0
        },
        {
          "field": "ebiasLog",
          "description": "bias to add to log energy",
          "type": "numeric",
          "default": 0.0
        },
        {
          "field": "ebiasRms",
          "description": "bias to add to rms energy",
          "type": "numeric",
          "default": 0.0
        },
        {
          "field": "ebiasSquare",
          "description": "bias to add to quadratic energy",
          "type": "numeric",
          "default": 0.0
        }
      ]
    },
    {
      "component": "cIntensity",
      "description": "This component computes simplified frame intensity (narrow band approximation). IMPORTANT: It expects UNwindowed raw PCM frames as input!! A Hamming window is internally applied and the resulting signal is squared bevore applying loudness compression, etc.",
      "readsFromLevels": [
        "reader.dmLevel"
      ],
      "writesToLevels": [
        "writer.dmLevel"
      ],
      "baseComponent": "cVectorProcessor",
      "fields": [
        {
          "field": "nameAppend",
          "description": "A string suffix to append to the input field names (default: empty)",
          "type": "string",
          "default": null
        },
        {
          "field": "intensity",
          "description": "1 = enable the output of intensity I (mean of squared input values multiplied by a Hamming window)",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "loudness",
          "description": "1 = enable the output of loudness L : L = (I/I0)^0.3 ; I0 = 0.000001 (for sample values normalised to the range -1..1)",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        }
      ]
    },
    {
      "component": "cMelspec",
      "description": "This component computes an N-band Mel/Bark/Semitone-frequency spectrum (critical band spectrum) by applying overlapping triangular filters equidistant on the Mel/Bark/Semitone-frequency scale to an FFT magnitude or power spectrum.",
      "readsFromLevels": [
        "reader.dmLevel"
      ],
      "writesToLevels": [
        "writer.dmLevel"
      ],
      "baseComponent": "cVectorProcessor",
      "fields": [
        {
          "field": "nBands",
          "description": "The number of Mel/Bark/Semitone band filters the filterbank from 'lofreq'-'hifreq' contains.",
          "type": "numeric",
          "default": 26.0
        },
        {
          "field": "lofreq",
          "description": "The lower cut-off frequency of the filterbank (Hz)",
          "type": "numeric",
          "default": 20.0
        },
        {
          "field": "hifreq",
          "description": "The upper cut-off frequency of the filterbank (Hz)",
          "type": "numeric",
          "default": 8000.0
        },
        {
          "field": "usePower",
          "description": "Set this to 1, to use the power spectrum instead of magnitude spectrum, i.e. if set this squares the input data",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "showFbank",
          "description": "If this is set to 1, the bandwidths and centre frequencies of the filters in the filterbank are printed to openSMILE log output (console and/or file)",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "htkcompatible",
          "description": "1 = enable htk compatible output (audio sample scaling -32767..+32767 instead of openSMILE's -1.0..1.0)",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "inverse",
          "description": "[NOT YET FULLY TESTED] 1 = compute fft magnitude spectrum from mel spectrum; Note that if this option is set, 'nBands' specifies the number of fft bands to create!",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "specScale",
          "description": "The frequency scale to design the critical band filterbank in (this is the scale in which the filter centre frequencies are placed equi-distant): \n  mel = Mel-frequency scale (m = 1127 ln (1+f/700))\n   bark = Bark scale approximation (Critical band rate z): z = [26.81 / (1.0 + 1960/f)] - 0.53\n   bark_schroed = Bark scale approximation due to Schroeder (1977): 6*ln( f/600 + [(f/600)^2+1]^0.5 )\n   bark_speex = Bark scale approximation as used in Speex codec package\n   semi = semi-tone scale with first note (0) = 'firstNote' (default 27.5Hz)  (s=12*log(f/firstNote)/log(2)) [experimental]\n   log = logarithmic scale with base 'logScaleBase' (default = 2)\n   lin(ear) = linear Hz scale.",
          "type": "string",
          "default": "mel",
          "allowedValues": [
            "mel",
            "bark",
            "bark_schroed",
            "bark_speex",
            "semi",
            "log",
            "lin",
            "linear"
          ]
        },
        {
          "field": "bwMethod",
          "description": "The method to use to compute filter bandwidth:\n  lr  : use centre frequencies of left and right neighbours (standard way for mel-spectra and mfcc)\n  erb : bandwidth based on critical bandwidth approximation (ERB), choose this option for computing HFCC instead of MFCC.\n  custom: use the 'halfBwTarg' option to specify a custom effective rectangular bandwidth of the triangular filters - this bandwidth is constant for all filters and independent of the center frequency.",
          "type": "string",
          "default": "lr",
          "allowedValues": [
            "lr",
            "erb",
            "custom"
          ]
        },
        {
          "field": "halfBwTarg",
          "description": "If bwMethod=='custom' then this options gives the effective rectangular bandwidth of the triangular filters in the target frequency scale (default mel). If showFbank=1 the actual bandwidth in Hz for each center frequency will be printed at startup.",
          "type": "numeric",
          "default": 1.0
        },
        {
          "field": "logScaleBase",
          "description": "The base for log scales (a log base of 2.0 - the default - corresponds to an octave target scale)",
          "type": "numeric",
          "default": 2.0
        },
        {
          "field": "firstNote",
          "description": "The first note (in Hz) for a semi-tone scale",
          "type": "numeric",
          "default": 27.5
        },
        {
          "field": "overrideFrameSizeSec",
          "description": "In case that the original FFT frame size in seconds cannot automatically be read from the input level meta data (i.e. for average spectra in a multi-frame-size setting), use this to manually override it and force the filters to be created based on the given frame size assumption.",
          "type": "numeric",
          "default": 0.0
        }
      ]
    },
    {
      "component": "cMfcc",
      "description": "This component computes Mel-frequency cepstral coefficients (MFCC) from a critical band spectrum (see 'cMelspec'). An I-DCT of type-II is used from transformation from the spectral to the cepstral domain. Liftering of cepstral coefficients is supported. HTK compatible values can be computed.",
      "readsFromLevels": [
        "reader.dmLevel"
      ],
      "writesToLevels": [
        "writer.dmLevel"
      ],
      "baseComponent": "cVectorProcessor",
      "fields": [
        {
          "field": "nameAppend",
          "description": "A string suffix to append to the input field names (default: empty)",
          "type": "string",
          "default": "mfcc"
        },
        {
          "field": "firstMfcc",
          "description": "The first MFCC to compute",
          "type": "numeric",
          "default": 1.0
        },
        {
          "field": "lastMfcc",
          "description": "The last MFCC to compute",
          "type": "numeric",
          "default": 12.0
        },
        {
          "field": "nMfcc",
          "description": "Use this option to specify the number of MFCC, instead of specifying lastMfcc",
          "type": "numeric",
          "default": 12.0
        },
        {
          "field": "melfloor",
          "description": "The minimum value allowed for melspectra when taking the log spectrum (this parameter will be forced to 1.0 when htkcompatible=1)",
          "type": "numeric",
          "default": 1e-08
        },
        {
          "field": "doLog",
          "description": "This defaults to 1 (on), set it to 0 to disable the log() operation on the (power) spectrum before applying the DCT. Note: If disabled, the output cannot be considered Cepstral coefficients anymore!",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "cepLifter",
          "description": "Parameter for cepstral 'liftering', set this to 0.0 to disable cepstral liftering",
          "type": "numeric",
          "default": 22.0
        },
        {
          "field": "htkcompatible",
          "description": "1 = append the 0-th coefficient at the end instead of placing it as the first element of the output vector",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "inverse",
          "description": "1/0 = on/off : comutation of inverse MFCC (i.e. input is MFCC array)",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "nBands",
          "description": "number of mel/bark bands to create when computing the inverse MFCC (must be the same as the number of bands the forward transform was performed on).",
          "type": "numeric",
          "default": 26.0
        },
        {
          "field": "printDctBaseFunctions",
          "description": "1/0 = on/off: print the dct base functions in octave compatible syntax to standard output",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        }
      ]
    },
    {
      "component": "cPlp",
      "description": "This component computes PLP and RASTA-PLP (currently the RASTA filter is not yet implemented) cepstral coefficients from a critical band spectrum (generated by the cMelspec component, for example).\n   The component is capable of performing the following processing steps: \n   1) Take the natural logarithm of the critical band powers (doLog)\n   2) RASTA filtering\n   3) Computation of auditory spectrum (equal loudness curve and loudness compression)\n   4) Inverse of the natural logarithm\n   5) Inverse DFT to obtain autocorrelation coefficients\n   6) Linear prediction analysis on autocorr. coeff.\n   7) Computation of cepstral coefficients from lp coefficients\n   8) Cepstral 'liftering'",
      "readsFromLevels": [
        "reader.dmLevel"
      ],
      "writesToLevels": [
        "writer.dmLevel"
      ],
      "baseComponent": "cVectorProcessor",
      "fields": [
        {
          "field": "lpOrder",
          "description": "The order of the linear predictor (5th order is optimal according to Hermansky 1990, JASA)",
          "type": "numeric",
          "default": 5.0
        },
        {
          "field": "nCeps",
          "description": "The number of cepstral coefficients (must be <= lpOrder, set to -1 for max. (=lpOrder))",
          "type": "numeric",
          "default": -1.0
        },
        {
          "field": "firstCC",
          "description": "The first cepstral coefficient to compute (set to 0 to include the 0th coefficient, which is defined as -log(1/lpcGain) )",
          "type": "numeric",
          "default": 1.0
        },
        {
          "field": "lastCC",
          "description": "The last cepstral coefficient to compute (set to -1 to use nCeps, else lastCC will override nCeps!)",
          "type": "numeric",
          "default": -1.0
        },
        {
          "field": "doLog",
          "description": "Take the log of input bands (1=yes / 0=no)",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "doAud",
          "description": "Do auditory processing (equal loudness curve and loudness compression) (1=yes / 0=no)",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "RASTA",
          "description": "Perform RASTA (temporal) filtering (1=yes / 0=no)",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "newRASTA",
          "description": "Perform RASTA (temporal) filtering (more stable filter, Type-II, initial filtering only with FIR part; thanks to Chris Landsiedl for this code!) (1=enable / 0=disable) Note: this option (if set to 1) will disable the 'RASTA' option.",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "rastaUpperCutoff",
          "description": "Upper cut-off frequency of RASTA bandpass filter in Hz",
          "type": "numeric",
          "default": 29.0
        },
        {
          "field": "rastaLowerCutoff",
          "description": "Lower cut-off frequency of RASTA bandpass filter in Hz",
          "type": "numeric",
          "default": 1.0
        },
        {
          "field": "doInvLog",
          "description": "Apply inverse logarithm after power compression (1=yes / 0=no)",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "doIDFT",
          "description": "Apply I(nverse)DFT after power compression and inverse log (1=yes / 0=no)",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "doLP",
          "description": "Do lp analysis on autocorrelation function (1=yes / 0=no)",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "doLpToCeps",
          "description": "Convert lp coefficients to cepstral coefficients (1=yes / 0=no)",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "cepLifter",
          "description": "Parameter for cepstral 'liftering', set to 0.0 to disable cepstral liftering",
          "type": "numeric",
          "default": 0.0
        },
        {
          "field": "compression",
          "description": "Compression factor for 'power law of hearing'",
          "type": "numeric",
          "default": 0.33
        },
        {
          "field": "melfloor",
          "description": "Minimum value of melspectra when computing mfcc (will be forced to 1.0 when htkcompatible=1)",
          "type": "numeric",
          "default": 9.3e-10
        },
        {
          "field": "htkcompatible",
          "description": "Set correct mel-floor and force HTK compatible PLP output (1/0 = yes/no)\n  htkcompatible == 1, forces the following settings:\n  - melfloor = 1.0 (signal scaling 0..32767*32767)\n  - append 0th coeff instead of having it as first value\n  - doAud = 1 , doLog=0 , doInvLog=0   (doIDFT, doLP, and doLpToCeps are not forced to 1, this enables generation of HTK compatible auditory spectra, etc. (these, of course, are not compatible, i.e. are not the same as HTK's PLP))\n  - the 0th audspec component is used as dc component in IDFT (else the DC component is zero)",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        }
      ]
    },
    {
      "component": "cSpectral",
      "description": "This component computes spectral features such as flux, roll-off, centroid, and user defined band energies (rectangular summation of FFT magnitudes), etc.",
      "readsFromLevels": [
        "reader.dmLevel"
      ],
      "writesToLevels": [
        "writer.dmLevel"
      ],
      "baseComponent": "cVectorProcessor",
      "fields": [
        {
          "field": "squareInput",
          "description": "1/0 = square input values (e.g. if input is magnitude and not power spectrum)",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "bands",
          "description": "bands[n] = LoFrq[Hz]-HiFrq[Hz]  (e.g. 0-250), compute energy in this spectral band (only integer frequencies are allowed!)",
          "type": "string",
          "default": "250-650"
        },
        {
          "field": "normBandEnergies",
          "description": "(1/0=yes/no) normalise the band energies to the total frame energy (-> relative band energies). Also affects 'harmonicity', normalises the average min to max variations in the spectrum by the total frame energy (sum of magnitudes or squares).",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "rollOff",
          "description": "rollOff[n] = X  (X in the range 0..1), compute X*100 percent spectral roll-off point",
          "type": "numeric",
          "default": 0.9
        },
        {
          "field": "specDiff",
          "description": "(1/0=yes/no) enable computation of spectral difference (root-mean-square of absolute differences over all bins)",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "specPosDiff",
          "description": "(1/0=yes/no) enable computation of spectral positive difference (sum of squared positive differences normalised by number of bins and then sqrt taken)",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "flux",
          "description": "(1/0=yes/no) enable computation of spectral flux",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "fluxCentroid",
          "description": "(1/0=yes/no) enable computation of spectral flux centroid (in Hz), i.e. the frequency with currently the most flux around it.",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "fluxAtFluxCentroid",
          "description": "(1/0=yes/no) enable computation of spectral flux only at and around (+- 2 bins) the centroid of flux (as computed by the 'fluxCentroid' option).",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "centroid",
          "description": "(1/0=yes/no) enable computation of spectral centroid",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "maxPos",
          "description": "(1/0=yes/no) enable computation of position of spectral maximum",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "minPos",
          "description": "(1/0=yes/no) enable computation of position of spectral minimum",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "entropy",
          "description": "(1/0=yes/no) enable computation of spectral entropy",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "standardDeviation",
          "description": "(1/0=yes/no) enable computation of spectral standard deviation (root of variance)",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "variance",
          "description": "(1/0=yes/no) enable computation of spectral variance (mpeg7: spectral spread)",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "skewness",
          "description": "(1/0=yes/no) enable computation of spectral skewness",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "kurtosis",
          "description": "(1/0=yes/no) enable computation of spectral kurtosis",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "slope",
          "description": "(1/0=yes/no) enable computation of spectral slope over maximal frequency range",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "slopes",
          "description": "slopes[n] = LoFrq[Hz]-HiFrq[Hz] (e.g. 0-5000), computes spectral slope in the given band (only integer frequencies are allowed!)",
          "type": "string",
          "default": null
        },
        {
          "field": "alphaRatio",
          "description": "(1/0=yes/no) enable computation of alpha ratio (ratio of energy above 1 kHz (up to 5 kHz) to energy below 1 kHz).",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "hammarbergIndex",
          "description": "(1/0=yes/no) enable computation of hammarberg index (ratio of energy peak (max) in 0-2 kHz region and energy peak (max) in 2-5 kHz region).",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "sharpness",
          "description": "(1/0=yes/no) enable computation of psychoacoustic parameter 'sharpness'. In order to obtain proper values, use a bark scale spectrum as input (see cSpecScale component).",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "tonality",
          "description": "(1/0=yes/no) enable computation of consonance (ratio of consonance/dissonance, based on intervals between spectral peaks). (NOT YET IMPLEMENTED)",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "harmonicity",
          "description": "(1/0=yes/no) enable computation of harmonicity (mean of consecutive local min-max differences). Optionally normalised by the total frame energy, if normBandEnergies is set to 1.",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "flatness",
          "description": "(1/0=yes/no) enable computation of spectral flatness (sfm = geometric_mean / arithmetic_mean of spectrum).",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "logFlatness",
          "description": "(1/0=yes/no) if flatness is enabled, output ln(flatness).",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "buggyRollOff",
          "description": "(1/0=yes/no) for backwards feature set compatibility, enable buggy roll-off computation (pre May 2013, pre 2.0 release).",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ],
          "recommendedValue": 0.0
        },
        {
          "field": "oldSlopeScale",
          "description": "(1/0=yes/no) for backwards feature set compatibility, enable (incorrectly) scaled spectral slope computation (pre July 2013, pre 2.0 final release). Enabled by default, to preserve compatibility with older feature sets. Disable in new designs!",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ],
          "recommendedValue": 0.0
        },
        {
          "field": "freqRange",
          "description": "range of spectrum to consider for spectral parameter computation (syntax: lowerHz-upperHz, e.g. 0-8000; use 0-0 (default) for full range)",
          "type": "string",
          "default": "0-0"
        },
        {
          "field": "useLogSpectrum",
          "description": "(1/0=yes/no) Compute the following parameters (if enabled) from the log spectrum instead of the power spectrum: spectral slope(s), centroid, maxpos/minpos, entropy, moments, sharpness, harmonicity, flatness. Please note, that the band energies are computed from the power spectrum, but the output will be in dB (log) if this option is enabled (1). Spectral roll-off and flux will always be computed from the power spectrum (no log).",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "specFloor",
          "description": "When using the log Spectrum, the square(!) of this value is used as a floor value for the power spectrum.",
          "type": "numeric",
          "default": 1e-07
        }
      ]
    },
    {
      "component": "cPitchACF",
      "description": "This component computes the fundamental frequency and the probability of voicing via an acf and cepstrum based method. The input must be an acf field and a cepstrum field (both generated by a cAcf component).",
      "readsFromLevels": [
        "reader.dmLevel"
      ],
      "writesToLevels": [
        "writer.dmLevel"
      ],
      "baseComponent": "cVectorProcessor",
      "fields": [
        {
          "field": "processArrayFields",
          "description": "1 = process each array field as one vector individually (and produce one output for each input array field). Only array fields (i.e. fields with more than one element) are processed if this is set. / 0 = process complete input frame as one vector, ignoring field/element structure",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "maxPitch",
          "description": "Maximum detectable pitch in Hz",
          "type": "numeric",
          "default": 500.0
        },
        {
          "field": "voiceProb",
          "description": "1/0 = on/off: output of voicing probability",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "voiceQual",
          "description": "1/0 = on/off: output of voice 'quality' (= ZCR of ACF)",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "HNR",
          "description": "1/0 = on/off; output of log (base e) harmonics-to-noise ratio (HNR) computed from the ACF, pre 2.0 compatibility.",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "HNRdB",
          "description": "1/0 = on/off; output of log (dB, base 10) harmonics-to-noise ratio (HNR) computed from the ACF. Recommended.",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "linHNR",
          "description": "1/0 = on/off; output of linear harmonics-to-noise ratio (HNR) computed from the ACF.",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "F0",
          "description": "1/0 = on/off: output of F0 (pitch) (Note: the pitch output is 0 in unvoiced segments)",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "F0raw",
          "description": "1/0 = on/off: output of raw F0 candidate without thresholding in unvoiced segments",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "F0env",
          "description": "1/0 = on/off: output of F0 envelope (expontial decay smoothing) (Note: this differs from the envelope computed by the cPitchBase descendant components, such as cPitchSHS!)",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "voicingCutoff",
          "description": "This sets the voicing probability threshold for pitch detection [0.0 - 1.0]. Frames with voicing probability values above this threshold will be considered as voiced.",
          "type": "numeric",
          "default": 0.55
        }
      ]
    },
    {
      "component": "cPitchSmoother",
      "description": "This component performs temporal pitch smoothing. Input: candidates produced by a pitchBase descendant (e.g. cPitchSHS). The voicing cutoff threshold is inherited from the input component, thus this smoother component does not provide its own threshold option.",
      "readsFromLevels": [
        "reader.dmLevel"
      ],
      "writesToLevels": [
        "writer.dmLevel"
      ],
      "baseComponent": "cVectorProcessor",
      "fields": [
        {
          "field": "processArrayFields",
          "description": "1 = process each array field as one vector individually (and produce one output for each input array field). Only array fields (i.e. fields with more than one element) are processed if this is set. / 0 = process complete input frame as one vector, ignoring field/element structure",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "medianFilter0",
          "description": "Apply median filtering of candidates as the FIRST processing step; filter length is 'medianFilter0' if > 0",
          "type": "numeric",
          "default": 0.0
        },
        {
          "field": "postSmoothing",
          "description": "Apply post processing (median and spike remover) over 'postSmoothing' frames (0=no smoothing or use default set by postSmoothingMethod)",
          "type": "numeric",
          "default": 0.0
        },
        {
          "field": "postSmoothingMethod",
          "description": "Post processing method to use. One of the following:\n   'none' disable post smoothing\n   'simple' simple post smoothing using only 1 frame delay (will smooth out 1 frame octave spikes)\n   'median' will apply a median filter to the output values (length = value of 'postProcessing')",
          "type": "string",
          "default": "simple",
          "allowedValues": [
            "none",
            "simple",
            "median"
          ]
        },
        {
          "field": "octaveCorrection",
          "description": "Enable intelligent cross candidate octave correction",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "F0final",
          "description": "1 = Enable output of final (corrected and smoothed) F0",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "F0finalEnv",
          "description": "1 = Enable output of envelope of final smoothed F0 (i.e. there will be no 0 values (except for end and beginning))",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "no0f0",
          "description": "1 = enable 'no zero F0', output data only when F0>0, i.e. a voiced frame is detected. This may cause problem with some functionals and framer components, which don't support this variable length data yet...",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "voicingFinalClipped",
          "description": "1 = Enable output of final smoothed and clipped voicing (pseudo) probability. 'Clipped' means that the voicing probability is set to 0 for unvoiced regions, i.e. where the probability lies below the voicing threshold.",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "voicingFinalUnclipped",
          "description": "1 = Enable output of final smoothed, raw voicing (pseudo) probability (UNclipped: not set to 0 during unvoiced regions).",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "F0raw",
          "description": "1 = Enable output of 'F0raw' copied from input",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "voicingC1",
          "description": "1 = Enable output of 'voicingC1' copied from input",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "voicingClip",
          "description": "1 = Enable output of 'voicingClip' copied from input",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        }
      ]
    },
    {
      "component": "cTonespec",
      "description": "This component computes (or rather estimates) a semi-tone spectrum from an FFT magnitude spectrum.",
      "readsFromLevels": [
        "reader.dmLevel"
      ],
      "writesToLevels": [
        "writer.dmLevel"
      ],
      "baseComponent": "cVectorProcessor",
      "fields": [
        {
          "field": "nameAppend",
          "description": "A string suffix to append to the input field names (default: empty)",
          "type": "string",
          "default": "note"
        },
        {
          "field": "nOctaves",
          "description": "The number of octaves the spectrum should span",
          "type": "numeric",
          "default": 6.0
        },
        {
          "field": "firstNote",
          "description": "The frequency of the first note (in Hz)",
          "type": "numeric",
          "default": 55.0
        },
        {
          "field": "filterType",
          "description": "The shape of the semitone filter:\n   tri (triangular)\n   trp (triangular-powered)\n   gau (gaussian)",
          "type": "string",
          "default": "gau",
          "allowedValues": [
            "tri",
            "trp",
            "gau"
          ]
        },
        {
          "field": "usePower",
          "description": "Compute the semi-tone spectrum from the power spectrum instead of the magnitudes (= square input values)",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "dbA",
          "description": "apply built-in dbA weighting to (power) spectrum (1/0 = yes/no)",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "printBinMap",
          "description": "1 = print mapping of fft bins to semi-tone intervals",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "printFilterMap",
          "description": "1 = print filter map",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        }
      ]
    },
    {
      "component": "cTonefilt",
      "description": "This component implements an on-line, sample by sample semi-tone filter bank which can be used as first step for the computation of CHROMA features as a replacement of cTonespec. The filter is based on correlating with a sine wave of the exact target frequency of a semi-tone for each note in the filter-bank.",
      "readsFromLevels": [
        "reader.dmLevel"
      ],
      "writesToLevels": [
        "writer.dmLevel"
      ],
      "baseComponent": "cDataProcessor",
      "fields": [
        {
          "field": "nameAppend",
          "description": "A string suffix to append to the input field names (default: empty)",
          "type": "string",
          "default": "tonefilt"
        },
        {
          "field": "nNotes",
          "description": "The number of semi-tone filters in the bank",
          "type": "numeric",
          "default": 48.0
        },
        {
          "field": "firstNote",
          "description": "The frequency of the first note in Hz",
          "type": "numeric",
          "default": 55.0
        },
        {
          "field": "decayF0",
          "description": "The gliding average decay coefficient for the first note (lowest frequency)",
          "type": "numeric",
          "default": 0.9995
        },
        {
          "field": "decayFN",
          "description": "The gliding average decay coefficient for the last note (highest frequency) (must be < decayF0!); decay coefficents for intermediate frequencies will be interpolated linearly from the start and end coefficients.",
          "type": "numeric",
          "default": 0.998
        },
        {
          "field": "outputPeriod",
          "description": "Specifies the period at which to produce output frames in seconds",
          "type": "numeric",
          "default": 0.1
        }
      ]
    },
    {
      "component": "cChroma",
      "description": "This component computes CHROMA features from a semi-tone scaled spectrum generated by the 'cTonespec' component.",
      "readsFromLevels": [
        "reader.dmLevel"
      ],
      "writesToLevels": [
        "writer.dmLevel"
      ],
      "baseComponent": "cVectorProcessor",
      "fields": [
        {
          "field": "nameAppend",
          "description": "A string suffix to append to the input field names (default: empty)",
          "type": "string",
          "default": "chroma"
        },
        {
          "field": "copyInputName",
          "description": "1 = copy the input name (and optionally append a suffix, see 'nameAppend' option), 0 = discard the input name and use only the 'nameAppend' string as new name.",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "octaveSize",
          "description": "The size of an octave, i.e. the number of output bins, or the interval to which the input bins are mapped via warping.",
          "type": "numeric",
          "default": 12.0
        },
        {
          "field": "silThresh",
          "description": "Chroma 'floor', i.e. silence threshold. If at least on element of the (unnormalised) chroma vector falls below the threshold, the vector will not be normalised, and a 0 vector will be output instead.",
          "type": "numeric",
          "default": 0.001
        }
      ]
    },
    {
      "component": "cCens",
      "description": "This component computes CENS (energy normalised and smoothed chroma features) from raw Chroma features generated by the 'cChroma' component.",
      "readsFromLevels": [
        "reader.dmLevel"
      ],
      "writesToLevels": [
        "writer.dmLevel"
      ],
      "baseComponent": "cVectorProcessor",
      "fields": [
        {
          "field": "nameAppend",
          "description": "A string suffix to append to the input field names (default: empty)",
          "type": "string",
          "default": "CENS"
        },
        {
          "field": "copyInputName",
          "description": "1 = copy the input name (and optionally append a suffix, see 'nameAppend' option), 0 = discard the input name and use only the 'nameAppend' string as new name.",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "window",
          "description": "The window function to use for temporal CENS smoothing; one of these: han (Hanning), ham (Hamming), bar (Bartlett)",
          "type": "string",
          "default": "han",
          "allowedValues": [
            "han",
            "ham",
            "bar"
          ]
        },
        {
          "field": "downsampleRatio",
          "description": "The integer ratio at which to downsample the resulting sequence of vectors. I.e. a value of 4 will average 4 frames and output 1 CENS frame.",
          "type": "numeric",
          "default": 10.0
        },
        {
          "field": "winlength",
          "description": "The length of the CENS smoothing window, in frames.",
          "type": "numeric",
          "default": 41.0
        },
        {
          "field": "winlength_sec",
          "description": "The length of the CENS smoothing window, in seconds. This will be rounded upwards (ceil) to the closest length in frames. It overrides winlength, if set.",
          "type": "numeric",
          "default": 0.41
        },
        {
          "field": "l2norm",
          "description": "1/0 = enable/disable normalisation of CENS vectors by their L2-norm.",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        }
      ]
    },
    {
      "component": "cHarmonics",
      "description": "This component computes statistics of F0 harmonics. It requires an F0 (Hertz) input field and a linear frequency axis magnitude spectrum as input.",
      "readsFromLevels": [
        "reader.dmLevel"
      ],
      "writesToLevels": [
        "writer.dmLevel"
      ],
      "baseComponent": "cVectorProcessor",
      "fields": [
        {
          "field": "processArrayFields",
          "description": "1 = process each array field as one vector individually (and produce one output for each input array field). Only array fields (i.e. fields with more than one element) are processed if this is set. / 0 = process complete input frame as one vector, ignoring field/element structure",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "includeSingleElementFields",
          "description": "1 = if in processArrayFields (1) mode, then also include single element fields.",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "f0ElementName",
          "description": "Name of F0 element in input vector to use.",
          "type": "string",
          "default": "F0final"
        },
        {
          "field": "f0ElementNameIsFull",
          "description": "1/0= f0ElementName is a partial name (glob with *x*) or the exact full name.",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "magSpecFieldName",
          "description": "Name of magnitude spectrum field in input vector to use.",
          "type": "string",
          "default": "pcm_fftMag"
        },
        {
          "field": "magSpecFieldNameIsFull",
          "description": "1/0= magSpecFieldName is a partial name (glob with *x*) or the exact full name.",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "formantFrequencyFieldName",
          "description": "Name of formant frequency field. Typcially formantFreqLpc",
          "type": "string",
          "default": null
        },
        {
          "field": "formantFrequencyFieldNameIsFull",
          "description": "1/0= formantFrequencyFieldName is a partial name (glob with *x*) or the exact full name.",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "formantBandwidthFieldName",
          "description": "Name of formant bandwidth field. Typically formantBandwidthLpc",
          "type": "string",
          "default": null
        },
        {
          "field": "formantBandwidthFieldNameIsFull",
          "description": "1/0= formantBandwidthFieldName is a partial name (glob with *x*) or the exact full name.",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "nHarmonics",
          "description": "Maximum number of harmonics to search for (including F0) (approximately Fmax / F_lowest_f0).",
          "type": "numeric",
          "default": 100.0
        },
        {
          "field": "firstHarmonicMagnitude",
          "description": "Index of first harmonic magnitude to output (0 is magnitude of F0).",
          "type": "numeric",
          "default": 1.0
        },
        {
          "field": "nHarmonicMagnitudes",
          "description": "Number of harmonic magnitudes to output. 0 to disable.",
          "type": "numeric",
          "default": 0.0
        },
        {
          "field": "outputLogRelMagnitudes",
          "description": "1 = output logarithmic magnitudes (dB) normalised by the magnitude of F0 (0dB), if nHarmonicMagnitudes > 0.",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "outputLinearMagnitudes",
          "description": "1 = output the linear magnitudes as obtained from the FFT for the nHarmonicMagnitudes harmonics (if nHarmonicMagnitudes > 0).",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "harmonicDifferences",
          "description": "Array that specifies harmonic differences (ratios in linear scale) to compute. Syntax for one element: H1-H2 (ratio of H1 to H2), H0 is fundamental frequency. A1,A2,...,AN is the amplitude (highest peak in the formant range) of the N-th formant, if formant frequency AND bandwidth information is given in the input (see formantFrequencyFieldName and formantBandwidthFieldName options).",
          "type": "string",
          "default": null
        },
        {
          "field": "harmonicDifferencesLog",
          "description": "1 = Harmonic differences in log magnitude scale (actually differences of the log values then).",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "harmonicDifferencesRatioLinear",
          "description": "1 = Harmonic differences in linear magnitude scale (actually ratios of the linear values then).",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "formantAmplitudes",
          "description": "1 = Enable output of formant amplitudes (amplitude of highest peak in the formant range, half bandwidth left and right of formant frequency).",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "formantAmplitudesLinear",
          "description": "1 = Linear formant amplitude output, requires formantAmplitudes=1 .",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "formantAmplitudesLogRel",
          "description": "1 = Logarithmic relative to F0 formant amplitude output in dB, requires formantAmplitudes=1 .",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "formantAmplitudesStart",
          "description": "First formant to compute amplitudes for, 0 is F0, 1 is first formant, etc.",
          "type": "numeric",
          "default": 1.0
        },
        {
          "field": "formantAmplitudesEnd",
          "description": "Last formant to compute amplitudes for. Default '-1' is last formant found in the input.",
          "type": "numeric",
          "default": -1.0
        },
        {
          "field": "computeAcfHnrLogdB",
          "description": "1 = enable HNR (logarithmic in dB) from ACF at F0 position (vs. total energy). Will be zero for unvoiced frames (where F0 = 0).",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "computeAcfHnrLinear",
          "description": "1 = enable HNR (linear ACF amplitude ratio) from ACF at F0 position (vs. total energy).  Will be zero for unvoiced frames (where F0 = 0).",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "logRelValueFloorUnvoiced",
          "description": "Sets the value that is returned for LogRel (relative to F0) type features when F0==0 (unvoiced). Logical default is the general floor of -201.0, however if unvoiced regions should always be zero, in order to be discarded/ignored e.g. by a functionals component, then this should be set to 0.0",
          "type": "numeric",
          "default": -201.0
        }
      ]
    },
    {
      "component": "cPitchSmootherViterbi",
      "description": "Viterbi algorithm to smooth pitch contours and remove octave jumps.",
      "readsFromLevels": [
        "reader.dmLevel",
        "reader2.dmLevel"
      ],
      "writesToLevels": [
        "writer.dmLevel"
      ],
      "baseComponent": "cDataProcessor",
      "fields": [
        {
          "field": "reader2",
          "description": "Configuration of the dataMemory reader sub-component which is used to read input frames with a certain lag (max. bufferLength!).",
          "type": "cDataReader"
        },
        {
          "field": "bufferLength",
          "description": "The length of the delay buffer in (input) frames. This is the amount of data that will be used for the Viterbi smoothing, and it is also the lag which the output is behind the input. The input level buffer must be at least bufferLength+1 in size!.",
          "type": "numeric",
          "default": 30.0
        },
        {
          "field": "F0final",
          "description": "1 = Enable output of final (corrected and smoothed) F0 -- linear scale",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "F0finalLog",
          "description": "1 = Enable output of final (corrected and smoothed) F0 in logarithmic representation (semitone scale with base note 27.5 Hz - a linear F0 equal to and below 29.136 Hz (= 1 on the semitone scale) will be clipped to an output value of 1, since 0 is reserved for unvoiced).",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "F0finalEnv",
          "description": "1 = Enable output of envelope of final smoothed F0 (i.e. there will be no 0 values (except for the beginning). Envelope method is to hold the last valid sample, no interpolation is performed. [EXPERIMENTAL!]",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "F0finalEnvLog",
          "description": "1 = Enable output of envelope of final smoothed F0 (i.e. there will be no 0 values (except for end and beginning)) in a logarithmic (semitone, base note 27.5 Hz - a linear F0 equal to and below 29.136 Hz (= 1 on the semitone scale) will be clipped to an output value of 1, since 0 is reserved for unvoiced) frequency scale. Envelope method is sample and hold, no interpolation is performed. [EXPERIMENTAL!]",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "no0f0",
          "description": "1 = enable 'no zero F0', output data only when F0>0, i.e. a voiced frame is detected. This may cause problem with some functionals and framer components, which don't support this variable length data yet...",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "voicingFinalClipped",
          "description": "1 = Enable output of final smoothed and clipped voicing (pseudo) probability. 'Clipped' means that the voicing probability is set to 0 for unvoiced regions, i.e. where the probability lies below the voicing threshold.",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "voicingFinalUnclipped",
          "description": "1 = Enable output of final smoothed, raw voicing (pseudo) probability (UNclipped: not set to 0 during unvoiced regions).",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "F0raw",
          "description": "1 = Enable output of 'F0raw' copied from input",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "voicingC1",
          "description": "1 = Enable output of 'voicingC1' copied from input",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "voicingClip",
          "description": "1 = Enable output of 'voicingClip' copied from input",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "wLocal",
          "description": "Viterbi weight for local log. voice probs. A higher weight here will favour candidates with a high voicing probability.",
          "type": "numeric",
          "default": 2.0
        },
        {
          "field": "wTvv",
          "description": "Viterbi weight for voiced-voiced transition. A higher weight here will favour a flatter pitch curve (less jumps)",
          "type": "numeric",
          "default": 10.0
        },
        {
          "field": "wTvvd",
          "description": "Viterbi weight for smoothness of voiced-voiced transition. A higher weight here will favour a flatter pitch curve (less jumps)",
          "type": "numeric",
          "default": 5.0
        },
        {
          "field": "wTvuv",
          "description": "Viterbi cost for voiced-unvoiced transitions. A higher value will reduce the number of voiced-unvoiced transitions.",
          "type": "numeric",
          "default": 10.0
        },
        {
          "field": "wThr",
          "description": "Viterbi cost bias for voice prob. crossing the voicing threshold. A higher value here will force voiced/unvoiced decisions by the Viterbi algorithm to be more close to the threshold based decision. A lower value, e.g. 0, will ignore the voicing threshold completely (not recommended).",
          "type": "numeric",
          "default": 4.0
        },
        {
          "field": "wRange",
          "description": "Viterbi weight for frequency range constraint. A higher value will enforce the given frequency weighting more strictly, i.e. favour pitch frequencies between 100 Hz and 300 Hz.",
          "type": "numeric",
          "default": 1.0
        },
        {
          "field": "wTuu",
          "description": "Viterbi cost for unvoiced-unvoiced transitions. There should be no need to change the default value of 0.",
          "type": "numeric",
          "default": 0.0
        }
      ]
    },
    {
      "component": "cPitchJitter",
      "description": "This component computes Voice Quality parameters Jitter (pitch period deviations) and Shimmer (pitch period amplitude deviations). It requires the raw PCM frames and the corresponding fundamental frequency (F0) as inputs.",
      "readsFromLevels": [
        "reader.dmLevel",
        "F0reader.dmLevel"
      ],
      "writesToLevels": [
        "writer.dmLevel"
      ],
      "baseComponent": "cDataProcessor",
      "fields": [
        {
          "field": "F0reader",
          "description": "Configuration of the dataMemory reader sub-component which is used to read the F0 estimate from a pitch component output (e.g. cPitchShs).",
          "type": "cDataReader"
        },
        {
          "field": "F0field",
          "description": "The name of the field in 'F0reader.dmLevel' containing the F0 estimate (in Hz) (usually F0final or F0raw) - full name, exact match!",
          "type": "string",
          "default": "F0final"
        },
        {
          "field": "searchRangeRel",
          "description": "The relative search range for period deviations (Jitter): maxT0, minT0 = (1.0 +/- searchRangeRel)*T0",
          "type": "numeric",
          "default": 0.1
        },
        {
          "field": "minNumPeriods",
          "description": "Minimum number of F0 periods to compute jitter/shimmer over. The frame size must be large enough to hold that number of periods for the extraction to be stable!",
          "type": "numeric",
          "default": 2.0
        },
        {
          "field": "minCC",
          "description": "Cross correlation threshold below which the periods will be rejected.",
          "type": "numeric",
          "default": 0.5
        },
        {
          "field": "jitterLocal",
          "description": "1 = enable computation of F0 jitter (period length variations). jitterLocal = the average absolute difference between consecutive periods, divided by the average period length of all periods in the frame",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "jitterDDP",
          "description": "1 = enable computation of F0 jitter (period length variations). jitterDDP = the average absolute difference between consecutive differences between consecutive periods, divided by the average period length of all periods in the frame",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "jitterLocalEnv",
          "description": "1 = compute envelope of jitterLocal (i.e. fill jitter values in unvoiced frames with value of last voiced segment). Use this in conjunction with statistical functionals such as means.",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "jitterDDPEnv",
          "description": "1 = compute envelope of jitterDDP (i.e. fill jitter values in unvoiced frames with value of last voiced segment). Use this in conjunction with statistical functionals such as means.",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "shimmerLocal",
          "description": "1 = enable computation of F0 shimmer (amplitude variations). shimmerLocal = the average absolute difference between the interpolated peak amplitudes of consecutive periods, divided by the average peak amplitude of all periods in the frame",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "shimmerLocalDB",
          "description": "1 = enable computation of F0 shimmer (amplitude variations) in decibel (dB). shimmerLocal = the average absolute difference between the interpolated peak amplitudes of consecutive periods, divided by the average peak amplitude of all periods in the frame",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "shimmerLocalEnv",
          "description": "1 = compute envelope of shimmerLocal (i.e. fill shimmer values in unvoiced frames with value of last voiced segment). Use this in conjunction with statistical functionals such as means.",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "shimmerLocalDBEnv",
          "description": "1 = compute envelope of shimmerLocalDB (i.e. fill shimmer values in unvoiced frames with value of last voiced segment). Use this in conjunction with statistical functionals such as means.",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "shimmerUseRmsAmplitude",
          "description": "1 = use average rms amplitude instead of peak amplitude.",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "harmonicERMS",
          "description": "1 = output of harmonic component RMS energy (energy average period waveform).",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "noiseERMS",
          "description": "1 = output of noise component RMS energy (energy of difference signal between repeated average period waveform and actual signal).",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "linearHNR",
          "description": "1 = output of harmonics to noise ratio computed from waveform signal (= harmonicERMS/noiseERMS)",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "logHNR",
          "description": "1 = output of logarithmic harmonics to noise ratio computed from waveform signal, using natural logarithm (base e) (logHNR = log(harmonicERMS/noiseERMS) )",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "lgHNRfloor",
          "description": "minimal value logHNR can be, to avoid very large negative numbers for small harmonic energies.",
          "type": "numeric",
          "default": -100.0
        },
        {
          "field": "onlyVoiced",
          "description": "1 = produce output only for voiced frames. I.e. do not output 0 jitter/shimmer values for unvoiced frames. WARNING: this option is not fully supported by the functionals component, yet.",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "refinedF0",
          "description": "1 = output refined F0 in a field named after the 'F0field' option.",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "sourceQualityMean",
          "description": "1 = compute larynx source quality mean per frame (similarity of pitch periods)",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "sourceQualityRange",
          "description": "1 = compute larynx source quality range per frame (max - min similarity of pitch periods)",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "usePeakToPeakPeriodLength",
          "description": "1 = use peak to peak period length instead of correlation peak position (should roughly be the same - the old version used the correlation peak pos., which is the default)",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "periodOutputFile",
          "description": "Dump period start/end/amplitude/length to file if this option is set to a filename.",
          "type": "string",
          "default": null
        },
        {
          "field": "inputMaxDelaySec",
          "description": "The maximum possible delay of the F0 input wrt. to the waveform in seconds. This occurs mainly for viterbi smoothing, for example. IT IS IMPORTANT that you set this parameter with care (summing up all delays like bufferLength of the viterbi smoother, etc.), otherwise the processing will hang or abort before the actual end of the input!",
          "type": "numeric",
          "default": 2.0,
          "required": true
        },
        {
          "field": "useBrokenJitterThresh",
          "description": "1 = enable compatibility with 2.2 and earlier versions with broken Jitter computation. Please specify this manually in all new configs (and update old configs to use value 0), as the default might change from 1 to 0 in future builds.",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ],
          "recommendedValue": 0.0
        }
      ]
    },
    {
      "component": "cPitchDirection",
      "description": "This component reads pitch data, detects pseudo syllables, and computes pitch direction estimates per syllable. Thereby the classes falling, flat, and rising are distinguished. \n    Required input fields: F0, F0env, and 'loudness' or 'RMSenergy'.",
      "readsFromLevels": [
        "reader.dmLevel"
      ],
      "writesToLevels": [
        "writer.dmLevel"
      ],
      "sendsMessagesToComponents": [
        "directionMsgRecp"
      ],
      "baseComponent": "cDataProcessor",
      "fields": [
        {
          "field": "ltbs",
          "description": "The size of the long-term average buffer in seconds",
          "type": "numeric",
          "default": 0.2
        },
        {
          "field": "stbs",
          "description": "The size of the short-term average buffer in seconds",
          "type": "numeric",
          "default": 0.05
        },
        {
          "field": "directionMsgRecp",
          "description": "Recipient component(s) for per syllable event-based pitch direction message (rise/fall/rise-fall/fall-rise message are sent only if and as ofter as a such event occurs on a syllable)",
          "type": "string",
          "default": null,
          "typeHint": "componentInstance,"
        },
        {
          "field": "speakingRateBsize",
          "description": "The buffer size for computation of speaking rate (in input frames, typical frame rate 100 fps)",
          "type": "numeric",
          "default": 100.0
        },
        {
          "field": "F0direction",
          "description": "1 = enable output of F0 direction as numeric value (fall: -1.0 / flat: 0.0 / rise: 1.0)",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "directionScore",
          "description": "1 = enable output of F0 direction score (short term mean - long term mean)",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "speakingRate",
          "description": "1 = enable output of current speaking rate in Hz (is is output for every frame, thus, a lot of redundancy here)",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "F0avg",
          "description": "1 = enable output of long term average F0",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "F0smooth",
          "description": "1 = enable output of exponentially smoothed F0",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "onlyTurn",
          "description": "1 = send pitch direction messages (directionMsgRecp) only during speech turns (voice activity) (according to turnStart/turnEnd messages received from cTurnDetector)",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "turnStartMessage",
          "description": "Use this option to define a custom message name for turn start messages, i.e. if you want to use voice activity start/end messages instead",
          "type": "string",
          "default": "turnStart"
        },
        {
          "field": "turnEndMessage",
          "description": "Use this option to define a custom message name for turn end messages, i.e. if you want to use voice activity start/end messages instead",
          "type": "string",
          "default": "turnEnd"
        },
        {
          "field": "F0fieldname",
          "description": "The name of the F0 data field to use for syllable detection and pitch direction analysis",
          "type": "string",
          "default": "F0"
        },
        {
          "field": "F0envFieldname",
          "description": "The name of the F0 envelope data field to use for syllable detection and pitch direction analysis",
          "type": "string",
          "default": "F0env"
        },
        {
          "field": "LoudnessFieldname",
          "description": "The name of the 'Loudness' data field (see cIntensity component) to use for syllable nuclei detection",
          "type": "string",
          "default": "loudness"
        },
        {
          "field": "RMSenergyFieldname",
          "description": "The name of the RMS energy data field to use for syllable detection",
          "type": "string",
          "default": "pcm_RMSenergy"
        }
      ]
    },
    {
      "component": "cPitchShs",
      "description": "This component computes the fundamental frequency via the Sub-Harmonic-Sampling (SHS) method (this is related to the Harmonic Product Spectrum method).",
      "readsFromLevels": [
        "reader.dmLevel"
      ],
      "writesToLevels": [
        "writer.dmLevel"
      ],
      "baseComponent": "cPitchBase",
      "fields": [
        {
          "field": "voicingCutoff",
          "description": "This sets the voicing (pseudo) probability threshold for pitch detection. Frames with voicing probability values above this threshold will be considered as voiced.",
          "type": "numeric",
          "default": 0.7
        },
        {
          "field": "inputFieldSearch",
          "description": "A part of the name to find the pitch detectors input field by ('Mag' searches e.g. for *Mag*, and will match fftMag fields)",
          "type": "string",
          "default": "Mag_logScale"
        },
        {
          "field": "octaveCorrection",
          "description": "1 = enable low-level octave correction tuned for the SHS algorithm (will affect F0C1, voicingC1 and F0raw output fields) [EXPERIMENTAL! MAY BREAK CORRECT PITCH DETECTION!]",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "shsWriter",
          "description": "Configuration of the dataMemory writer sub-component which is used to dump the SHS spectrum.",
          "type": "cDataWriterShs"
        },
        {
          "field": "nHarmonics",
          "description": "Number of harmonics to consider for subharmonic sampling (feasible values: 5-15)",
          "type": "numeric",
          "default": 15.0
        },
        {
          "field": "compressionFactor",
          "description": "The factor for successive compression of sub-harmonics",
          "type": "numeric",
          "default": 0.85
        },
        {
          "field": "greedyPeakAlgo",
          "description": "1 = use new algorithm to return all maximum score candidates regardless of their order. The old algorithm added new candidates only if they were higher scored as the first one. Enabling this seems to require different viterbi parameters for smoothing though, so use with caution! Default behaviour is 'off' so that we remain backwards-compatible.",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "shsSpectrumOutput",
          "description": "If set to 1, then the sub-harmonic summation spectra frames will be written to the level specified by shsWriter.dmLevel.",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "lfCut",
          "description": "> 0 = remove low frequency information up to given frequency from input spectrum by zeroing all bins below.",
          "type": "numeric",
          "default": 0.0
        }
      ]
    },
    {
      "component": "cLpc",
      "description": "This component computes linear predictive coding (LPC) coefficients from PCM frames. Burg's algorithm and the standard ACF/Durbin based method are implemented for LPC coefficient computation. The output of LPC filter coefficients, reflection coefficients, residual signal, and LP spectrum is supported.",
      "readsFromLevels": [
        "reader.dmLevel"
      ],
      "writesToLevels": [
        "writer.dmLevel"
      ],
      "baseComponent": "cVectorProcessor",
      "fields": [
        {
          "field": "method",
          "description": "This option sets the lpc method to use. Choose between: 'acf' acf (autocorrelation) method with Levinson-Durbin algorithm , 'burg' Burg method (N. Anderson (1978))",
          "type": "string",
          "default": "acf",
          "allowedValues": [
            "acf",
            "burg"
          ]
        },
        {
          "field": "p",
          "description": "Predictor order (= number of lpc coefficients)",
          "type": "numeric",
          "default": 8.0
        },
        {
          "field": "saveLPCoeff",
          "description": "1 = save LP coefficients to output",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "lpGain",
          "description": "1 = save lpc gain (error) in output vector",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "saveRefCoeff",
          "description": "1 = save reflection coefficients to output",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "residual",
          "description": "1 = compute lpc residual signal and store in output frame",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "residualGainScale",
          "description": "1 = scale lpc residual signal by lpc gain (divides each frame by gain)",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "forwardFilter",
          "description": "1 = apply forward instead of inverse filter when computing residual",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "lpSpectrum",
          "description": "1 = compute lp spectrum using 'lpSpecDeltaF' as frequency resolution or 'lpSpecBins' bins",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "forwardLPspec",
          "description": "1 = compute forward filter transfer function as LP spectrum, instead of old default behaviour of computing spectrum of inverse filter.",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "forwardLPspecFloor",
          "description": "Floor value to add to all spectral bins of inverse LP spectrum when inverting the spectrum (1/x) to avoid division by 0. Default: 10^-13.",
          "type": "numeric",
          "default": 1e-13
        },
        {
          "field": "lpSpecDeltaF",
          "description": "frequency resolution of lp spectrum (only applicable if 'lpSpectrum=1')",
          "type": "numeric",
          "default": 10.0
        },
        {
          "field": "lpSpecBins",
          "description": "number of bins to compute lp spectrum for (overrides lpSpecDeltaF) (only applicable if 'lpSpectrum=1')",
          "type": "numeric",
          "default": 100.0
        }
      ]
    },
    {
      "component": "cLsp",
      "description": "This component computes LSP (line spectral pair frequencies, also known as LSF) from LPC coefficients by partial factorisation of the LPC polynomial.",
      "readsFromLevels": [
        "reader.dmLevel"
      ],
      "writesToLevels": [
        "writer.dmLevel"
      ],
      "baseComponent": "cVectorProcessor",
      "fields": [
        {
          "field": "processArrayFields",
          "description": "1 = process each array field as one vector individually (and produce one output for each input array field). Only array fields (i.e. fields with more than one element) are processed if this is set. / 0 = process complete input frame as one vector, ignoring field/element structure",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        }
      ]
    },
    {
      "component": "cFormantLpc",
      "description": "This component computes formant frequencies and bandwidths by solving for the roots of the LPC polynomial. The formant trajectories can and should be smoothed by the cFormantSmoother component.",
      "readsFromLevels": [
        "reader.dmLevel"
      ],
      "writesToLevels": [
        "writer.dmLevel"
      ],
      "baseComponent": "cVectorProcessor",
      "fields": [
        {
          "field": "processArrayFields",
          "description": "1 = process each array field as one vector individually (and produce one output for each input array field). Only array fields (i.e. fields with more than one element) are processed if this is set. / 0 = process complete input frame as one vector, ignoring field/element structure",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "nFormants",
          "description": "The maximum number of formants to detect (set to < 0 to automatically detect the maximum number of possible formants (nLpcCoeff - 1)",
          "type": "numeric",
          "default": -1.0
        },
        {
          "field": "saveFormants",
          "description": "If set to 1, output formant frequencies [field name: formantFreqLpc]",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "saveIntensity",
          "description": "If set to 1, output formant frame intensity [field name: formantFrameIntensity]",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "saveNumberOfValidFormants",
          "description": "If set to 1, output the number of valid formants [field name: nFormants]",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "saveBandwidths",
          "description": "If set to 1, output formant bandwidths [field name: formantBandwidthLpc]",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "minF",
          "description": "The minimum of the formant frequency search range",
          "type": "numeric",
          "default": 50.0
        },
        {
          "field": "maxF",
          "description": "The maximum detectable formant frequency",
          "type": "numeric",
          "default": 5500.0
        },
        {
          "field": "useLpSpec",
          "description": "Experimental option: If set to 1, computes the formants from peaks found in the 'lpSpectrum' field instead of root solving the lpc coefficient polynomial",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "medianFilter",
          "description": "1 = enable formant post processing by a median filter of length 'medianFilter' (recommended: 5) (will be rounded up to the next odd number); 0 to disable median filter.",
          "type": "numeric",
          "default": 0.0
        },
        {
          "field": "octaveCorrection",
          "description": "Experimental option: 1 = prevent formant octave jumps (esp. when medianFilter is enabled) by employing simple 'octave' correction. 0 = no correction.",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        }
      ]
    },
    {
      "component": "cFormantSmoother",
      "description": "This component performs temporal formant smoothing. Input: candidates produced by a formant** component AND(!) - appended - an F0final or voicing field (which is 0 for unvoiced frames and non-zero for voiced frames). Output: Smoothed formant frequency contours.",
      "readsFromLevels": [
        "reader.dmLevel"
      ],
      "writesToLevels": [
        "writer.dmLevel"
      ],
      "baseComponent": "cVectorProcessor",
      "fields": [
        {
          "field": "processArrayFields",
          "description": "1 = process each array field as one vector individually (and produce one output for each input array field). Only array fields (i.e. fields with more than one element) are processed if this is set. / 0 = process complete input frame as one vector, ignoring field/element structure",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "medianFilter0",
          "description": "If > 0, applies median filtering of candidates as the FIRST processing step; the filter length is the value of 'medianFilter0' if > 0",
          "type": "numeric",
          "default": 0.0
        },
        {
          "field": "postSmoothing",
          "description": "If > 0, applies post processing (median and spike remover) over 'postSmoothing' frames (0=no smoothing or use default set by postSmoothingMethod)",
          "type": "numeric",
          "default": 0.0
        },
        {
          "field": "postSmoothingMethod",
          "description": "The post processing method to use. One of the following:\n   'none' disable post smoothing\n   'simple' simple post smoothing using only 1 frame delay (will smooth out 1 frame octave spikes)\n   'median' will apply a median filter to the output values (length = value of 'postProcessing')",
          "type": "string",
          "default": "simple",
          "allowedValues": [
            "none",
            "simple",
            "median"
          ]
        },
        {
          "field": "F0field",
          "description": "The input field containing either F0final or voicingFinalClipped (i.e. a field who's value is 0 for unvoiced frames and != 0 otherwise), (the name you give here is a partial name, i.e. the actual field names will be matched against *'F0field'*). Note: do not use the *Env (envelope) fields here, they are != 0 for unvoiced frames!",
          "type": "string",
          "default": "F0final"
        },
        {
          "field": "formantBandwidthField",
          "description": "The input field containing formant bandwidths (the name you give here is a partial name, i.e. the actual field names will be matched against *formantBandwidthField*)",
          "type": "string",
          "default": "formantBand"
        },
        {
          "field": "formantFreqField",
          "description": "The input field containing formant frequencies (the name you give here is a partial name, i.e. the actual field names will be matched against *formantFreqField*)",
          "type": "string",
          "default": "formantFreq"
        },
        {
          "field": "formantFrameIntensField",
          "description": "The input field containing formant frame intensity (the name you give here is a partial name, i.e. the actual field names will be matched against *formantFrameIntensField*)",
          "type": "string",
          "default": "formantFrameIntens"
        },
        {
          "field": "intensity",
          "description": "If set to 1, output formant intensity",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "nFormants",
          "description": "This sets the maximum number of smoothed formants to output (set to 0 to disable the output of formants and bandwidths)",
          "type": "numeric",
          "default": 5.0
        },
        {
          "field": "formants",
          "description": "If set to 1, output formant frequencies (also see 'nFormants' option)",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "bandwidths",
          "description": "If set to 1, output formant bandwidths (also see 'nFormants' option)",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "saveEnvs",
          "description": "If set to 1, output formant frequency and bandwidth envelopes instead(!) of the actual data (i.e. the last value of a voiced frame is used for the following unvoiced frames).",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "no0f0",
          "description": "'no zero F0': if set to 1, output data only when F0>0, i.e. a voiced frame is detected. This may cause problem with some functionals and framer components, which don't support this variable length data yet...",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        }
      ]
    },
    {
      "component": "cFunctionals",
      "description": "computes functionals from input frames, this component uses various cFunctionalXXXX sub-components, which implement the actual functionality",
      "readsFromLevels": [
        "reader.dmLevel"
      ],
      "writesToLevels": [
        "writer.dmLevel"
      ],
      "baseComponent": "cWinToVecProcessor",
      "fields": [
        {
          "field": "Extremes",
          "description": "functional sub-config of type cFunctionalExtremes",
          "type": "cFunctionalExtremes"
        },
        {
          "field": "Means",
          "description": "functional sub-config of type cFunctionalMeans",
          "type": "cFunctionalMeans"
        },
        {
          "field": "Peaks",
          "description": "functional sub-config of type cFunctionalPeaks",
          "type": "cFunctionalPeaks"
        },
        {
          "field": "Peaks2",
          "description": "functional sub-config of type cFunctionalPeaks2",
          "type": "cFunctionalPeaks2"
        },
        {
          "field": "Segments",
          "description": "functional sub-config of type cFunctionalSegments",
          "type": "cFunctionalSegments"
        },
        {
          "field": "Onset",
          "description": "functional sub-config of type cFunctionalOnset",
          "type": "cFunctionalOnset"
        },
        {
          "field": "Moments",
          "description": "functional sub-config of type cFunctionalMoments",
          "type": "cFunctionalMoments"
        },
        {
          "field": "Crossings",
          "description": "functional sub-config of type cFunctionalCrossings",
          "type": "cFunctionalCrossings"
        },
        {
          "field": "Percentiles",
          "description": "functional sub-config of type cFunctionalPercentiles",
          "type": "cFunctionalPercentiles"
        },
        {
          "field": "Regression",
          "description": "functional sub-config of type cFunctionalRegression",
          "type": "cFunctionalRegression"
        },
        {
          "field": "Samples",
          "description": "functional sub-config of type cFunctionalSamples",
          "type": "cFunctionalSamples"
        },
        {
          "field": "Times",
          "description": "functional sub-config of type cFunctionalTimes",
          "type": "cFunctionalTimes"
        },
        {
          "field": "DCT",
          "description": "functional sub-config of type cFunctionalDCT",
          "type": "cFunctionalDCT"
        },
        {
          "field": "Lpc",
          "description": "functional sub-config of type cFunctionalLpc",
          "type": "cFunctionalLpc"
        },
        {
          "field": "Modulation",
          "description": "functional sub-config of type cFunctionalModulation",
          "type": "cFunctionalModulation"
        },
        {
          "field": "functionalsEnabled",
          "description": "Array that defines the enabled functionals\n    The following functionals are available (sub-components) (Attention: the names are case-SENSITIVE!):\n     (#) \t(name)    \t\t(description)\n      1.\tExtremes \t\t  extreme values (max, min, range, maxPos, minPos, ...)\n      2.\tMeans \t\t  various mean values (arithmetic, geometric, quadratic, ...)\n      3.\tPeaks \t\t  number of peaks and various measures associated with peaks, such as mean of peaks, mean distance between peaks, etc. Peak finding is based on : x(t-1) < x(t) > x(t+1).\n      4.\tPeaks2 \t\t  number of peaks and various measures associated with peaks, such as mean of peaks, mean distance between peaks, etc. Peak finding is based on : x(t-1) < x(t) > x(t+1) plus an advanced post filtering of low relative amplitude peaks. See source code for brief description of peak picking algorithm. This component provides a new and improved algorithm for peak detection, as compared to cFunctionalPeaks component.\n      5.\tSegments \t\t  number of segments based on simple delta thresholding\n      6.\tOnset \t\t  relative position of the first onset and the last offset based on simple thresholding. Number of onsets and offsets can also be computed.\n      7.\tMoments \t\t  statistical moments (standard deviation, variance, skewness, kurtosis)\n      8.\tCrossings \t\t  zero-crossing rate, mean crossing rate, dc offset, min, and max value\n      9.\tPercentiles \t\t  percentile values and inter-percentile ranges (including quartiles, etc.). This component sorts the input array and then chooses the value at the index closest to p*buffer_len for the p-th percentile (p=0..1).\n      10.\tRegression \t\t  linear and quadratic regression coefficients and corresponding linear and quadratic regression errors. Linear regression line: y = m*x + t ; quadratic regression parabola: y = a*x^2 + b*x + c . Algorithm used: Minimum mean square error, direct analytic solution. This component also computes the centroid of the contour.\n      11.\tSamples \t\tsampled values at equidistant frames\n      12.\tTimes \t\t  up- and down-level times + rise and fall, left- and right-curve times, duration, etc.\n      13.\tDCT \t\t  DCT coefficients\n      14.\tLpc \t\t  LP coefficients as functionals\n      15.\tModulation \t\t  Modulation Spectrum",
          "type": "string",
          "default": null
        },
        {
          "field": "nonZeroFuncts",
          "description": "If this is set to 1, functionals are only applied to input values unequal 0. If this is set to 2, functionals are only applied to input values greater than 0.",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "functNameAppend",
          "description": "Specifies a string prefix to append to the functional name (which is appended to the input feature name)",
          "type": "string",
          "default": null
        },
        {
          "field": "masterTimeNorm",
          "description": "This option specifies how all components should normalise times, if they generate output values related to durations. You can change the 'norm' parameter of individual functional components to overwrite this master value. You can choose one of the following normalisation methods: \n   'segment' (or: 'turn') : normalise to the range 0..1, the result indicates relative turn length )\n   'second'  (absolute time in seconds) \n   'frame' (absolute time in number of frames of input level)",
          "type": "string",
          "default": "segment",
          "allowedValues": [
            "segment",
            "segments",
            "turn",
            "turns",
            "second",
            "seconds",
            "frame",
            "frames"
          ],
          "suggestedValues": [
            "segment",
            "turn",
            "second",
            "frame"
          ]
        },
        {
          "field": "preserveFields",
          "description": "If set to 1, preserves the field structure (and metadata, TODO!), of the input vector structure. If set to 0 (default) the output will only have fields with a single element.",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        }
      ]
    },
    {
      "component": "cLibsvmSink",
      "description": "This component writes data to a text file in LibSVM feature file format. For the 'on-the-fly' classification component see 'cLibsvmliveSink'.",
      "readsFromLevels": [
        "reader.dmLevel"
      ],
      "baseComponent": "cDataSink",
      "fields": [
        {
          "field": "filename",
          "description": "Output filename of libsvm formant file",
          "type": "string",
          "default": "smileoutput.lsvm"
        },
        {
          "field": "lag",
          "description": "output data <lag> frames behind",
          "type": "numeric",
          "default": 0.0
        },
        {
          "field": "append",
          "description": "Whether to append to existing file or not (1/0 = yes/no)",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "timestamp",
          "description": "1 = print timestamp attribute (0 = no)",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "instanceBase",
          "description": "If not empty, print instance name attribute <instanceBase_Nr>",
          "type": "string",
          "default": ""
        },
        {
          "field": "instanceName",
          "description": "If not empty, print instance name attribute <instanceName>",
          "type": "string",
          "default": ""
        },
        {
          "field": "class",
          "description": "Optional definition of class-name strings (each element is the name of one class, i.e. if you have 7 classes, the array should have seven entries; the names will be mapped to class numbers internally, since the libsvm format requires numbers as class labels). This feature allows for passing ground-truth information by class name (using the targetStrAll or targetStr options) directly on the command-line and makes post-editing of feature files obsolete.",
          "type": "string",
          "default": "classX"
        },
        {
          "field": "targetNum",
          "description": "Targets/Ground truths (as numbers/indicies) for each instance",
          "type": "numeric",
          "default": 0.0
        },
        {
          "field": "targetStr",
          "description": "Targets/Ground truths (as strings) for each instance",
          "type": "string",
          "default": "classX"
        },
        {
          "field": "targetNumAll",
          "description": "Target/Ground truth (as numbers/indicies) for all instances",
          "type": "numeric",
          "default": 0.0
        },
        {
          "field": "targetStrAll",
          "description": "Target/Ground truth (as strings) for all instances",
          "type": "string",
          "default": "classX"
        }
      ]
    },
    {
      "component": "cDataWriter",
      "description": "This is the dataMemory interface component that writes vector or matrix data to a dataMemory level. A writer can write only to a single level in the dataMemory, this level cannot be changed during the run-time phase.",
      "fields": [
        {
          "field": "dmInstance",
          "description": "The cDataMemory instance this writer shall connect to. This allows for complex configurations with multiple, independent data memories. For most applications the default 'dataMemory' should be reasonable. This is also the assumed default when automatically generating a configuration file.",
          "type": "string",
          "default": "dataMemory"
        },
        {
          "field": "dmLevel",
          "description": "The data memory level this writer will write data to. You can specify any name here, this writer will register and create a level of this name in the dataMemory during initialisation of openSMILE. Please be aware of the fact that only one writer can write to a data memory level, therefore you are not allowed to use the same name again in a 'dmLevel' option of any other component in the same config.",
          "type": "string",
          "default": null,
          "required": true
        },
        {
          "field": "levelconf",
          "description": "This structure specifies an optional configuration of this data memory level.\n   If this is given, it will overwrite any defaults or inherited values from input levels. For details see the help on the configuration type 'cDataMemoryLevel'.",
          "type": "cDataMemoryLevel"
        }
      ]
    },
    {
      "component": "cDataReader",
      "description": "This is the dataMemory interface component that reads data as vector or matrix from dataMemory component. It is used internally by all dataProcessor, dataSource, and dataSink components. A cDataReader can read from one or more data memory levels. In the latter case a single vector is returned which consists of all individual vectors concattenated. Reading from multiple levels implies waiting for data on the 'slowest' level, since only completely concattenated frames are read.",
      "fields": [
        {
          "field": "dmInstance",
          "description": "The name of the dataMemory instance this reader should connect to.",
          "type": "string",
          "default": "dataMemory"
        },
        {
          "field": "dmLevel",
          "description": "The level in the data memory instance specified by 'dmInstance' which to read from. If this array element contains more than one element, this reader will read data from multiple input levels, and concattenate the data to generate a single frame/vector. It is a good practice to have unique field names in all levels that you wish to concatenate. Note: If reading from multiple levels, the reader can only return a successfully read frame, if data is available for reading on all input levels. If data is missing on one level, the reader cannot output data, even if data is present on the other levels.",
          "type": "string",
          "default": null,
          "required": true,
          "typeHint": "dmLevel"
        },
        {
          "field": "forceAsyncMerge",
          "description": "1/0 = yes/no : force framewise merging of levels with differing frame period, if multiple levels are specified in dmLevel",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "errorOnFullInputIncomplete",
          "description": "1/0 = yes/no : 1 = abort with an error if full input matrix reading is activated (frameSize=0 & frameStep=0 => frameMode=full) and beginning of matrix (curR) is not 0, (if this option is set to 0, only a warning is shown)",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        }
      ]
    },
    {
      "component": "cDataSource",
      "description": "This is a base class for components, which write data to dataMemory, but do not read from it.",
      "writesToLevels": [
        "writer.dmLevel"
      ],
      "fields": [
        {
          "field": "writer",
          "description": "The configuration of the cDataWriter subcomponent, which handles the dataMemory interface for data output",
          "type": "cDataWriter"
        },
        {
          "field": "buffersize",
          "description": "The buffer size for the output level in frames (this overwrites buffersize_sec)",
          "type": "numeric",
          "default": 0.0
        },
        {
          "field": "buffersize_sec",
          "description": "The buffer size for the output level in seconds",
          "type": "numeric",
          "default": 0.0
        },
        {
          "field": "blocksize",
          "description": "A size of data blocks to write at once, in frames (same as blocksizeW for source only components, this overwrites blocksize_sec, if set)",
          "type": "numeric",
          "default": 0.0
        },
        {
          "field": "blocksizeW",
          "description": "The size of data blocks to write in frames (this overwrites blocksize and blocksize_sec, if it is set) (this option is provided for compatibility only... it is exactly the same as 'blocksize')",
          "type": "numeric",
          "default": 0.0
        },
        {
          "field": "blocksize_sec",
          "description": "The size of data blocks to write at once, in seconds",
          "type": "numeric",
          "default": 0.0
        },
        {
          "field": "blocksizeW_sec",
          "description": "The size of data blocks to write at once, in seconds (this option overwrites blocksize_sec!) (this option is provided for compatibility only... it is exactly the same as 'blocksize')",
          "type": "numeric",
          "default": 0.0
        },
        {
          "field": "period",
          "description": "(optional) The period of the input frames (in seconds), if it cannot be determined from the input file format. (if set and != 0, this will overwrite any automatically set values, e.g. from samplerate and writer.levelconf etc. (NOTE: this behaviour also depends on the source component, whether it overwrites period in configureWriter() or whether it keeps the period if it is != 0.0))",
          "type": "numeric",
          "default": 0.0
        },
        {
          "field": "basePeriod",
          "description": "(optional) The base period of the input data (in seconds). The default -1.0 will force the code to use the value of period (unless overwritten by configureWriter().)",
          "type": "numeric",
          "default": -1.0
        }
      ]
    },
    {
      "component": "cDataSink",
      "description": "This is a base class for components reading from (and not writing to) the dataMemory and dumping/passing data to external entities.",
      "readsFromLevels": [
        "reader.dmLevel"
      ],
      "fields": [
        {
          "field": "reader",
          "description": "The configuration of the cDataReader subcomponent, which handles the dataMemory interface for reading of input",
          "type": "cDataReader"
        },
        {
          "field": "blocksize",
          "description": "The size of the data blocks to read at once, in frames (overwrites blocksize_sec, if set)",
          "type": "numeric",
          "default": 0.0
        },
        {
          "field": "blocksizeR",
          "description": "The size of the data blocks to read at once, in frames (this overwrites blocksize and blocksize_sec!) (this option is provided for compatibility only... it is exactly the same as 'blocksize')",
          "type": "numeric",
          "default": 0.0
        },
        {
          "field": "blocksize_sec",
          "description": "The size of the data blocks to read at once, in seconds",
          "type": "numeric",
          "default": 0.0
        },
        {
          "field": "blocksizeR_sec",
          "description": "The size of the data blocks to read at once, in seconds (this overwrites blocksize_sec!) (this option is provided for compatibility only... it is exactly the same as 'blocksize')",
          "type": "numeric",
          "default": 0.0
        },
        {
          "field": "errorOnNoOutput",
          "description": "1 = show an error message if no output was written by this sink during this run.",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        }
      ]
    },
    {
      "component": "cDataProcessor",
      "description": "This is an abstract base class for all components which read data from the data memory and write new data to the data memory.",
      "readsFromLevels": [
        "reader.dmLevel"
      ],
      "writesToLevels": [
        "writer.dmLevel"
      ],
      "fields": [
        {
          "field": "reader",
          "description": "The configuration of the cDataReader subcomponent, which handles the dataMemory interface for data input",
          "type": "cDataReader"
        },
        {
          "field": "writer",
          "description": "The configuration of the cDataWriter subcomponent, which handles the dataMemory interface for data output",
          "type": "cDataWriter"
        },
        {
          "field": "buffersize",
          "description": "The buffer size for the output level in frames (default [0] = same as input level), this option overwrites 'buffersize_sec'",
          "type": "numeric",
          "default": 0.0
        },
        {
          "field": "buffersize_sec",
          "description": "The buffer size for the output level in seconds (default [0] = same as input level)",
          "type": "numeric",
          "default": 0.0
        },
        {
          "field": "blocksize",
          "description": "The size of data blocks to process in frames (this sets both blocksizeR and blocksizeW, and overwrites blocksize_sec)",
          "type": "numeric",
          "default": 0.0
        },
        {
          "field": "blocksizeR",
          "description": "The size of data blocks to read in frames (overwrites blocksize)",
          "type": "numeric",
          "default": 0.0
        },
        {
          "field": "blocksizeW",
          "description": "The size of data blocks to write in frames (overwrites blocksize)",
          "type": "numeric",
          "default": 0.0
        },
        {
          "field": "blocksize_sec",
          "description": "size of data blocks to process in seconds (this sets both blocksizeR_sec and blocksizeW_sec)",
          "type": "numeric",
          "default": 0.0
        },
        {
          "field": "blocksizeR_sec",
          "description": "size of data blocks to read in seconds (overwrites blocksize_sec!)",
          "type": "numeric",
          "default": 0.0
        },
        {
          "field": "blocksizeW_sec",
          "description": "size of data blocks to write in seconds (overwrites blocksize_sec!)",
          "type": "numeric",
          "default": 0.0
        },
        {
          "field": "nameAppend",
          "description": "A string suffix to append to the input field names (default: empty)",
          "type": "string",
          "default": null
        },
        {
          "field": "copyInputName",
          "description": "1 = copy the input name (and optionally append a suffix, see 'nameAppend' option), 0 = discard the input name and use only the 'nameAppend' string as new name.",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "EOIlevel",
          "description": "set the EOI counter threshold at which to act in EOI mode (for full input processing). Required e.g. for multi-level EOI chains to avoid running full input functionals/windows on incomplete first EOI iteration data.",
          "type": "numeric",
          "default": 0.0
        }
      ]
    },
    {
      "component": "cPitchBase",
      "description": "Base class for all pitch classes, no functionality on its own!",
      "readsFromLevels": [
        "reader.dmLevel"
      ],
      "writesToLevels": [
        "writer.dmLevel"
      ],
      "baseComponent": "cVectorProcessor",
      "fields": [
        {
          "field": "processArrayFields",
          "description": "1 = process each array field as one vector individually (and produce one output for each input array field). Only array fields (i.e. fields with more than one element) are processed if this is set. / 0 = process complete input frame as one vector, ignoring field/element structure",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "maxPitch",
          "description": "Maximum detectable pitch in Hz",
          "type": "numeric",
          "default": 620.0
        },
        {
          "field": "minPitch",
          "description": "Minimum detectable pitch in Hz",
          "type": "numeric",
          "default": 52.0
        },
        {
          "field": "nCandidates",
          "description": "The number of F0 candidates to output [1-20] (0 disables ouput of candidates AND their voicing probs.)",
          "type": "numeric",
          "default": 3.0
        },
        {
          "field": "scores",
          "description": "1/0 = on/off: output of F0 candidates scores, if available",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "voicing",
          "description": "1/0 = on/off: output of voicing probability for F0 candidates",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "F0C1",
          "description": "1/0 = on/off: output of raw best F0 candidate without thresholding in unvoiced segments",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "voicingC1",
          "description": "1/0 = on/off: output of output voicing (pseudo) probability for best candidate",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "F0raw",
          "description": "1/0 = on/off: output of raw F0 (best candidate), > 0 only for voiced segments (using voicingCutoff threshold)",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "voicingClip",
          "description": "1/0 = on/off: output of voicing of raw F0 (best candidate), > 0 only for voiced segments (using voicingCutoff threshold)",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "voicingCutoff",
          "description": "This sets the voicing (pseudo) probability threshold for pitch detection. Frames with voicing probability values above this threshold will be considered as voiced.",
          "type": "numeric",
          "default": 1.0
        },
        {
          "field": "inputFieldSearch",
          "description": "A part of the name to find the pitch detectors input field by ('Mag' searches e.g. for *Mag*, and will match fftMag fields)",
          "type": "string",
          "default": "Mag"
        },
        {
          "field": "octaveCorrection",
          "description": "If this pitch detector algorithm offers algorithm specific low-level octave correction, enable it",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        }
      ]
    },
    {
      "component": "cFunctionalExtremes",
      "description": "extreme values (max, min, range, maxPos, minPos, ...)",
      "fields": [
        {
          "field": "max",
          "description": "1/0=enable/disable output of maximum value",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "min",
          "description": "1/0=enable/disable output of minimum value",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "range",
          "description": "1/0=enable/disable output of range (max-min)",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "maxpos",
          "description": "1/0=enable/disable output of position of maximum value (relative to the input segment length, in seconds, or in frames, see the 'norm' option or the 'masterTimeNorm' option of the cFunctionals parent component)",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "minpos",
          "description": "1/0=enable/disable output of position of minimum value (relative to the input segment length, in seconds, or in frames, see the 'norm' option or the 'masterTimeNorm' option of the cFunctionals parent component)",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "amean",
          "description": "1/0=enable/disable output of arithmetic mean",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "maxameandist",
          "description": "1/0=enable/disable output of (max-arithmetic_mean)",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "minameandist",
          "description": "1/0=enable/disable output of (arithmetic_mean-min)",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "norm",
          "description": "This option specifies how this component should normalise times (if it generates output values related to durations): \n   'segment' (or: 'turn') : normalise to the range 0..1, the result is the relative length wrt. to the segment length )\n   'second'  (absolute time in seconds) \n   'frame' (absolute time in number of frames of input level)",
          "type": "string",
          "default": "frames",
          "allowedValues": [
            "segment",
            "segments",
            "turn",
            "turns",
            "second",
            "seconds",
            "frame",
            "frames"
          ],
          "suggestedValues": [
            "segment",
            "turn",
            "second",
            "frame"
          ]
        }
      ]
    },
    {
      "component": "cFunctionalMeans",
      "description": "various mean values (arithmetic, geometric, quadratic, ...)",
      "fields": [
        {
          "field": "amean",
          "description": "1/0=enable/disable output of arithmetic mean",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "absmean",
          "description": "1/0=enable/disable output of arithmetic mean of absolute values",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "qmean",
          "description": "1/0=enable/disable output of quadratic mean",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "nzamean",
          "description": "1/0=enable/disable output of arithmetic mean (of non-zero values only)",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "nzabsmean",
          "description": "1/0=enable/disable output of arithmetic mean of absolute values (of non-zero values only)",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "nzqmean",
          "description": "1/0=enable/disable output of quadratic mean (of non-zero values only)",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "nzgmean",
          "description": "1/0=enable/disable output of geometric mean (of absolute values of non-zero values only)",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "nnz",
          "description": "1/0=enable/disable output of number of non-zero values (relative to the input segment length, in seconds, or in frames, see the 'norm' option or the 'masterTimeNorm' option of the cFunctionals parent component)",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "flatness",
          "description": "1/0=enable/disable output of contour flatness (ratio of geometric mean and absolute value arithmetic mean(absmean)))",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "posamean",
          "description": "1/0=enable/disable output of arithmetic mean of positive values only (usually you would apply this to a differential signal to measure how much the original signal is rising)",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "negamean",
          "description": "1/0=enable/disable output of arithmetic mean of negative values only",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "posqmean",
          "description": "1/0=enable/disable output of quadratic mean of positive values only",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "posrqmean",
          "description": "1/0=enable/disable output of root of quadratic mean of positive values only",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "negqmean",
          "description": "1/0=enable/disable output of quadratic mean of negative values only",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "negrqmean",
          "description": "1/0=enable/disable output of root of quadratic mean of negative values only",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "rqmean",
          "description": "1/0=enable/disable output of square root of quadratic mean",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "nzrqmean",
          "description": "1/0=enable/disable output of square root of quadratic mean of non zero values",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "norm",
          "description": "This option specifies how this component should normalise times (if it generates output values related to durations): \n   'segment' (or: 'turn') : normalise to the range 0..1, the result is the relative length wrt. to the segment length )\n   'second'  (absolute time in seconds) \n   'frame' (absolute time in number of frames of input level)",
          "type": "string",
          "default": "frames",
          "allowedValues": [
            "segment",
            "segments",
            "turn",
            "turns",
            "second",
            "seconds",
            "frame",
            "frames"
          ],
          "suggestedValues": [
            "segment",
            "turn",
            "second",
            "frame"
          ]
        }
      ]
    },
    {
      "component": "cFunctionalPeaks",
      "description": "number of peaks and various measures associated with peaks, such as mean of peaks, mean distance between peaks, etc. Peak finding is based on : x(t-1) < x(t) > x(t+1).",
      "fields": [
        {
          "field": "numPeaks",
          "description": "1/0=enable/disable output of number of peaks [output name: numPeaks]",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "meanPeakDist",
          "description": "1/0=enable/disable output of mean distance between peaks (relative to the input segment length, in seconds, or in frames, see the 'norm' option or the 'masterTimeNorm' option of the cFunctionals parent component) [output name: meanPeakDist]",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "peakMean",
          "description": "1/0=enable/disable output of arithmetic mean of peaks [output name: peakMean]",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "peakMeanMeanDist",
          "description": "1/0=enable/disable output of arithmetic mean of peaks - arithmetic mean of all values [output name: peakMeanMeanDist]",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "peakDistStddev",
          "description": "1/0=enable/disable output of standard deviation of inter peak distances [output name: peakDistStddev]",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "norm",
          "description": "This option specifies how this component should normalise times (if it generates output values related to durations): \n   'segment' (or: 'turn') : normalise to the range 0..1, the result is the relative length wrt. to the segment length )\n   'second'  (absolute time in seconds) \n   'frame' (absolute time in number of frames of input level)",
          "type": "string",
          "default": "frames",
          "allowedValues": [
            "segment",
            "segments",
            "turn",
            "turns",
            "second",
            "seconds",
            "frame",
            "frames"
          ],
          "suggestedValues": [
            "segment",
            "turn",
            "second",
            "frame"
          ]
        },
        {
          "field": "overlapFlag",
          "description": "1/0=yes/no frames overlap (i.e. compute peaks locally only)",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        }
      ]
    },
    {
      "component": "cFunctionalPeaks2",
      "description": "number of peaks and various measures associated with peaks, such as mean of peaks, mean distance between peaks, etc. Peak finding is based on : x(t-1) < x(t) > x(t+1) plus an advanced post filtering of low relative amplitude peaks. See source code for brief description of peak picking algorithm. This component provides a new and improved algorithm for peak detection, as compared to cFunctionalPeaks component.",
      "fields": [
        {
          "field": "numPeaks",
          "description": "1/0=enable/disable output of number of peaks (if norm=segment or frame) and rate of peaks per time (1 second) if norm=second.",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "meanPeakDist",
          "description": "1/0=enable/disable output of mean distance between peaks (relative to the input segment length, in seconds, or in frames, see the 'norm' option or the 'masterTimeNorm' option of the cFunctionals parent component)",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "meanPeakDistDelta",
          "description": "1/0=enable/disable output of mean difference between consecutive inter peak distances (relative to the input segment length, in seconds, or in frames, see the 'norm' option or the 'masterTimeNorm' option of the cFunctionals parent component) [NOT YET IMPLEMENTED!]",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "peakDistStddev",
          "description": "1/0=enable/disable output of standard deviation of inter peak distances",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "peakRangeAbs",
          "description": "1/0=enable/disable output of peak range (max peak value - min peak value)",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "peakRangeRel",
          "description": "1/0=enable/disable output of peak range (max peak value - min peak value) / arithmetic mean",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "peakMeanAbs",
          "description": "1/0=enable/disable output of arithmetic mean of peaks (local maxima)",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "peakMeanMeanDist",
          "description": "1/0=enable/disable output of arithmetic mean of peaks - arithmetic mean of all values (mean of peaks to signal mean distance)",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "peakMeanRel",
          "description": "1/0=enable/disable output of arithmetic mean of peaks (local maxima) / arithmetic mean of all values (mean of peaks to signal mean ratio ~ peakMeanMeanRatio)",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "ptpAmpMeanAbs",
          "description": "1/0=enable/disable output of mean peak to peak (amplitude) difference",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "ptpAmpMeanRel",
          "description": "1/0=enable/disable output of mean peak to peak (amplitude) difference / range of signal",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "ptpAmpStddevAbs",
          "description": "1/0=enable/disable output of mean peak to peak (amplitude) standard deviation",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "ptpAmpStddevRel",
          "description": "1/0=enable/disable output of mean peak to peak (amplitude) standard deviation / range of signal",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "minRangeAbs",
          "description": "1/0=enable/disable output of local minima range (max minmum value - min minimum value)",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "minRangeRel",
          "description": "1/0=enable/disable output of local minima range (max minmum value - min minimum value) / arithmetic mean",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "minMeanAbs",
          "description": "1/0=enable/disable output of arithmetic mean of local minima",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "minMeanMeanDist",
          "description": "1/0=enable/disable output of arithmetic mean of local minima - arithmetic mean of all values",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "minMeanRel",
          "description": "1/0=enable/disable output of arithmetic mean of local minima / arithmetic mean",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "mtmAmpMeanAbs",
          "description": "1/0=enable/disable output of mean minimum to minimum (amplitude) difference",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "mtmAmpMeanRel",
          "description": "1/0=enable/disable output of mean minimum to minimum (amplitude) difference / range of signal",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "mtmAmpStddevAbs",
          "description": "1/0=enable/disable output of mean minimum to minimum (amplitude) standard deviation",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "mtmAmpStddevRel",
          "description": "1/0=enable/disable output of mean minimum to minimum (amplitude) standard deviation / range of signal",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "meanRisingSlope",
          "description": "1/0=enable/disable output of the mean of the rising slopes (rising slope is the slope of the line connecting a local minimum (or the beginning of input sample) with the following local maximum/peak or the end of input sample)",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "maxRisingSlope",
          "description": "1/0=enable/disable output of maximum rising slope",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "minRisingSlope",
          "description": "1/0=enable/disable output of minimum rising slope",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "stddevRisingSlope",
          "description": "1/0=enable/disable output of the standard deviation of the rising slopes",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "covRisingSlope",
          "description": "1/0=enable/disable output of the coefficient of variation (std. dev. divided by arithmetic mean) of the rising slopes",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "meanFallingSlope",
          "description": "1/0=enable/disable output of the mean of the falling slopes (falling slope is the slope of the line connecting a local maximum/peak (or the beginning of input sample) with the following local minimum (or the end of input sample))",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "maxFallingSlope",
          "description": "1/0=enable/disable output of maximum falling slope.",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "minFallingSlope",
          "description": "1/0=enable/disable output of minimum falling slope",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "stddevFallingSlope",
          "description": "1/0=enable/disable output of the standard deviation of the falling slopes",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "covFallingSlope",
          "description": "1/0=enable/disable output of the coefficient of variation (std. dev. divided by arithmetic mean) of the falling slopes",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "norm",
          "description": "This option specifies how this component should normalise times (if it generates output values related to durations): \n   'segment' (or: 'turn') : normalise to the range 0..1, the result is the relative length wrt. to the segment length )\n   'second'  (absolute time in seconds) \n   'frame' (absolute time in number of frames of input level)",
          "type": "string",
          "default": "frames",
          "allowedValues": [
            "segment",
            "segments",
            "turn",
            "turns",
            "second",
            "seconds",
            "frame",
            "frames"
          ],
          "suggestedValues": [
            "segment",
            "turn",
            "second",
            "frame"
          ]
        },
        {
          "field": "noClearPeakList",
          "description": "1 = don't clear the peak list when a new segment is processed. This should never be used, unless you need compatibility with old (buggy!) behaviour. If you are using a config file with peak2 functionals from before 05. Sept. 2012, you need to enable this option to be compatible with old models and results.",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ],
          "recommendedValue": 0.0
        },
        {
          "field": "absThresh",
          "description": "Gives an absolute threshold for the minimum peak height. Use with caution, use only if you know what you are doing. If this option is not set, relThresh will be used.",
          "type": "numeric",
          "default": 0.0
        },
        {
          "field": "relThresh",
          "description": "Gives the threshold relative to the input contour range, which is used to remove peaks and minimima below this threshold. Valid values: 0..1, a higher value will remove more peaks, while a lower value will keep more and less salient peaks. If not using dynRelThresh=1 you should use a default value of ~0.10 otherwise a default of ~0.35",
          "type": "numeric",
          "default": 0.1
        },
        {
          "field": "dynRelThresh",
          "description": "1/0 = enable disable dynamic relative threshold. Instead of converting the relThresh to an absolute threshold relThresh*range, the threshold is applied as: abs(a/b-1.0) < relThresh , where a is always larger than b.",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "posDbgOutp",
          "description": "Filename for debug output of peak positions. The file will be created initially (unless 'posDbgAppend' is set to 1) and values for consecutive input frames will be appended, separated by a '---' marker line.",
          "type": "string",
          "default": null
        },
        {
          "field": "posDbgAppend",
          "description": "Append to debug ouptut file instead of overwriting it at startup. If the file does not exist, it will be created, even if this option is set to 1.",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "consoleDbg",
          "description": "Debug output of peak positions to console if no output file is given (an output file will override this option).",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "doRatioLimit",
          "description": "(1/0) = yes/no. Apply soft limiting of ratio features (mean relative etc.) in order to avoid high uncontrolled output values if the denominator is close to 0. For strict compatibility with pre 2.2 openSMILE releases (also release candidates 2.2rc1), set it to 0. Default in new versions is 1 (enabled).",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        }
      ]
    },
    {
      "component": "cFunctionalSegments",
      "description": "number of segments based on simple delta thresholding",
      "fields": [
        {
          "field": "maxNumSeg",
          "description": "Maximum number of segments to detect. Use growDynSegBuffer=1 to automatically increase this size if more segments are detected. Use norm=seconds or norm=frames in this time to avoid having inconsistent results.",
          "type": "numeric",
          "default": 20.0
        },
        {
          "field": "segmentationAlgorithm",
          "description": "Method to use for segmenting the input contour. Possible values are:\n  delta : new segments start when the signal changes more than 'rangeRelThreshold' when the current frame is compared to a running average computed over a length of ravgLng = Nin/(maxNumSeg/2) frames (Nin is the length of the input contour in frames).\n  (m)(NA)relTh : segment boundaries each time the short term running average (over 3 frames) of the signal rises above predefined relative (to the signal range) value thresholds (NA version: don't use running average, use signal directly instead; m version: relative thresholds are relative to the arithmetic mean).\n  (NA)absTh : segment boundaries each time the short-time running average (3 frames) of the signal rises above predefined absolute value thresholds (NA version: don't use running average, use signal values directly instead).\n  chX : segments are regions of continuous input samples of value X and continuous segments of non-X samples, i.e. segment boundaries are at changes from X to non-X values.\n  nonX : segment boundaries are at changes from X to non-X, but only non-X value sequences are considered as segments.\n  eqX : segment boundaries are at changes from X to non-X, but only equal to X value sequences are considered as segments.\n  ltX : segment boundaries are at changes from greater equal X to smaller X, but only smaller X sequences are considered as segments.\n  gtX :  segment boundaries are at changes from smaller equal X to greater X, but only greater X sequences are considered as segments.\n  geqX :  segment boundaries are at changes from greater equal X to smaller X, but only greater equal X sequences are considered as segments.\n  leqX : segment boundaries are at changes from smaller equal X to greater X, but only smaller equal X sequences are considered as segments.",
          "type": "string",
          "default": "delta",
          "allowedValues": [
            "delta",
            "relTh",
            "mrelTh",
            "NArelTh",
            "mNArelTh",
            "absTh",
            "NAabsTh",
            "chX",
            "nonX",
            "eqX",
            "ltX",
            "gtX",
            "geqX",
            "leqX"
          ]
        },
        {
          "field": "ravgLng",
          "description": "If set to a value > 0, forces the length of the running average window to this value (for the delta thresholding method).",
          "type": "numeric",
          "default": 0.0
        },
        {
          "field": "thresholds",
          "description": "An array of thresholds, used if 'segmentationAlgorithm' is set to either 'relTh' or 'absTh'. The values specified here are then either relative thresholds (relative to the range of the input), or absolute value thresholds.",
          "type": "numeric",
          "default": 0.0
        },
        {
          "field": "X",
          "description": "The value of X for the 'chX','nonX','eqX','ltX','gtX','geqX', and 'leqX' segmentation methods/algorithms.",
          "type": "numeric",
          "default": 0.0
        },
        {
          "field": "XisRel",
          "description": "1= X is a threshold relative to the range of the input / 0= X is an absolute valued threshold.",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "rangeRelThreshold",
          "description": "The segment threshold relative to the signal's range (max-min), when 'segmentationAlgorithm' is set to 'delta'.",
          "type": "numeric",
          "default": 0.2
        },
        {
          "field": "numSegments",
          "description": "1/0=enable/disable output of the number of segments (output is relative to maxNumSeg if norm=segment or the absolute value if norm=frames, and for norm=seconds the output is the number of segments per second)",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "meanSegLen",
          "description": "1/0=enable/disable output of the mean segment length (relative to the input segment length, in seconds, or in frames, see the 'norm' option or the 'masterTimeNorm' option of the cFunctionals parent component)",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "maxSegLen",
          "description": "1/0=enable/disable output of the maximum segment length (relative to the input segment length, in seconds, or in frames, see the 'norm' option or the 'masterTimeNorm' option of the cFunctionals parent component)",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "minSegLen",
          "description": "1/0=enable/disable output of the minimum segment length (relative to the input segment length, in seconds, or in frames, see the 'norm' option or the 'masterTimeNorm' option of the cFunctionals parent component)",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "segLenStddev",
          "description": "1/0=enable/disable output of the standard deviation of the segment lengths (relative to the input segment length, in seconds, or in frames, see the 'norm' option or the 'masterTimeNorm' option of the cFunctionals parent component)",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "norm",
          "description": "This option specifies how this component should normalise times (if it generates output values related to durations): \n   'segment' (or: 'turn') : normalise to the range 0..1, the result is the relative length wrt. to the segment length )\n   'second'  (absolute time in seconds) \n   'frame' (absolute time in number of frames of input level)",
          "type": "string",
          "default": "segment",
          "allowedValues": [
            "segment",
            "segments",
            "turn",
            "turns",
            "second",
            "seconds",
            "frame",
            "frames"
          ],
          "suggestedValues": [
            "segment",
            "turn",
            "second",
            "frame"
          ]
        },
        {
          "field": "dbgPrint",
          "description": "1= enable debug output with segment boundary begin and end coordinates",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "segMinLng",
          "description": "Minimum segment length in input level frames. The segmentation algorithms EqX, NonX, and ChX always use this value. The old (buggy) versions of these algorithms (if useOldBuggyChX = 1), never use this value, they instead compute it as InputLength/maxNumSeg - 1. All other algorithms compute the value segMinLng as inputLength/maxNumSeg if this option is not set explicitly, otherwise they use the value this option is set to (in this case it overrides maxNumSeg, i.e. the maximum number of segments that can be detected might differ from the value maxNumSeg is set to).",
          "type": "numeric",
          "default": 3.0
        },
        {
          "field": "pauseMinLng",
          "description": "Minimum length of a pause for the segmentation algorithms EqX and NonX in input level frames.",
          "type": "numeric",
          "default": 2.0
        },
        {
          "field": "useOldBuggyChX",
          "description": "1 = Use old buggy version of the ChX, EqX and NonX code (configs up to 12.06.2012); available only for compatibility. Do not use in new configs!",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ],
          "recommendedValue": 0.0
        },
        {
          "field": "growDynSegBuffer",
          "description": "1 = Dynamically grow the segment buffer (i.e. maxNumSeg = infinite) by maxNumSeg segments at a time if more segments are detected.",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        }
      ]
    },
    {
      "component": "cFunctionalOnset",
      "description": "relative position of the first onset and the last offset based on simple thresholding. Number of onsets and offsets can also be computed.",
      "fields": [
        {
          "field": "threshold",
          "description": "The absolute threshold used for onset/offset detection (i.e. the first onset will be where the input value is above the threshold for the first time)",
          "type": "numeric",
          "default": 0.0
        },
        {
          "field": "thresholdOnset",
          "description": "A separate threshold only for onset detection. This will override the 'threshold' option, if set",
          "type": "numeric",
          "default": 0.0
        },
        {
          "field": "thresholdOffset",
          "description": "A separate threshold only for offset detection. This will override the 'threshold' option, if set",
          "type": "numeric",
          "default": 0.0
        },
        {
          "field": "useAbsVal",
          "description": "1/0=yes/no : apply thresholds to absolute input value instead of original input value",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "onsetPos",
          "description": "1/0=enable/disable output of relative position (relative to the input segment length, in seconds, or in frames, see the 'norm' option or the 'masterTimeNorm' option of the cFunctionals parent component) of first onset found [output name: onsetPos]",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "offsetPos",
          "description": "1/0=enable/disable output of position of last offset found (relative to the input segment length, in seconds, or in frames, see the 'norm' option or the 'masterTimeNorm' option of the cFunctionals parent component) [output name: offsetPos]",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "numOnsets",
          "description": "1/0=enable/disable output of the number of onsets found [output name: numOnsets]",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "numOffsets",
          "description": "1/0=enable/disable output of the number of offsets found (this is usually redundant and the same as numOnsets, use this only for special applications where it may make sense to use it) [output name: numOffsets]",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "onsetRate",
          "description": "1/0=enable/disable output of on-set rate, i.e. the number of onsets per second.",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "norm",
          "description": "This option specifies how this component should normalise times (if it generates output values related to durations): \n   'segment' (or: 'turn') : normalise to the range 0..1, the result is the relative length wrt. to the segment length )\n   'second'  (absolute time in seconds) \n   'frame' (absolute time in number of frames of input level)",
          "type": "string",
          "default": "segment",
          "allowedValues": [
            "segment",
            "segments",
            "turn",
            "turns",
            "second",
            "seconds",
            "frame",
            "frames"
          ],
          "suggestedValues": [
            "segment",
            "turn",
            "second",
            "frame"
          ]
        }
      ]
    },
    {
      "component": "cFunctionalMoments",
      "description": "statistical moments (standard deviation, variance, skewness, kurtosis)",
      "fields": [
        {
          "field": "variance",
          "description": "1/0=enable/disable output of variance",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "stddev",
          "description": "1/0=enable/disable output of standard deviation",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "skewness",
          "description": "1/0=enable/disable output of skewness",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "kurtosis",
          "description": "1/0=enable/disable output of kurtosis",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "amean",
          "description": "1/0=enable/disable output of arithmetic mean",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "stddevNorm",
          "description": "(2)/1/0=(enable compatible)/enable/disable output of standard deviation normalised to the absolute value of the arithmetic mean (stddev/abs(mean), also referred to as 'coefficient of variance'). NOTE: in older pre 2.2-final versions of openSMILE, this option computed stddev/mean without the abs() operation. To enable a behaviour compatible to this, set this option to the value 2.",
          "type": "numeric",
          "default": 0.0
        },
        {
          "field": "doRatioLimit",
          "description": "(1/0) = yes/no. Apply soft limiting of stddevNorm ratio feature in order to avoid high uncontrolled output values if the denominator is close to 0. For strict compatibility with pre 2.2 openSMILE releases (also release candidates 2.2rc1), set it to 0 (current default)",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        }
      ]
    },
    {
      "component": "cFunctionalCrossings",
      "description": "zero-crossing rate, mean crossing rate, dc offset, min, and max value",
      "fields": [
        {
          "field": "zcr",
          "description": "1/0=enable/disable output of zero crossing rate",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "mcr",
          "description": "1/0=enable/disable output of mean crossing rate (the rate at which the signal crosses its arithmetic mean value (same as zcr for mean normalised signals)",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "amean",
          "description": "1/0=enable/disable output of arithmetic mean",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        }
      ]
    },
    {
      "component": "cFunctionalPercentiles",
      "description": "percentile values and inter-percentile ranges (including quartiles, etc.). This component sorts the input array and then chooses the value at the index closest to p*buffer_len for the p-th percentile (p=0..1).",
      "fields": [
        {
          "field": "quartiles",
          "description": "1/0=enable/disable output of all quartiles (overrides individual settings quartile1, quartile2, and quartile3)",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "quartile1",
          "description": "1/0=enable/disable output of quartile1 (0.25)",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "quartile2",
          "description": "1/0=enable/disable output of quartile2 (0.50)",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "quartile3",
          "description": "1/0=enable/disable output of quartile3 (0.75)",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "iqr",
          "description": "1/0=enable/disable output of all inter-quartile ranges (overrides individual settings iqr12, iqr23, and iqr13)",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "iqr12",
          "description": "1/0=enable/disable output of inter-quartile range 1-2 (quartile2-quartile1)",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "iqr23",
          "description": "1/0=enable/disable output of inter-quartile range 2-3 (quartile3-quartile2)",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "iqr13",
          "description": "1/0=enable/disable output of inter-quartile range 1-3 (quartile3-quartile1)",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "iqq",
          "description": "1/0=enable/disable output of all inter-quartile quotients (ratios) (overrides individual settings iqq12, iqq23, and iqq13)",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "iqq12",
          "description": "1/0=enable/disable output of inter-quartile quotient q1/q2",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "iqq23",
          "description": "1/0=enable/disable output of inter-quartile quotient q2/q3",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "iqq13",
          "description": "1/0=enable/disable output of inter-quartile quotient q1/q3",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "percentile",
          "description": "Array of p*100 percent percentiles to compute. p = 0..1. Array size indicates the number of total percentiles to compute (excluding quartiles), duplicate entries are not checked for and not removed  : percentile[n] = p (p=0..1)",
          "type": "numeric",
          "default": 0.9
        },
        {
          "field": "pctlrange",
          "description": "Array that specifies which inter percentile ranges to compute. A range is specified as 'n1-n2' (where n1 and n2 are the indicies of the percentiles as they appear in the percentile[] array, starting at 0 with the index of the first percentile)",
          "type": "string",
          "default": "0-1"
        },
        {
          "field": "pctlquotient",
          "description": "Array that specifies which inter percentile quotients to compute. A quotient is specified as 'n1-n2' (where n1 and n2 are the indicies of the percentiles as they appear in the percentile[] array, starting at 0 with the index of the first percentile). The quotient is computed as n1/n2.",
          "type": "string",
          "default": "0-1"
        },
        {
          "field": "interp",
          "description": "If set to 1, percentile values will be linearly interpolated, instead of being rounded to the nearest index in the sorted array",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        }
      ]
    },
    {
      "component": "cFunctionalRegression",
      "description": "linear and quadratic regression coefficients and corresponding linear and quadratic regression errors. Linear regression line: y = m*x + t ; quadratic regression parabola: y = a*x^2 + b*x + c . Algorithm used: Minimum mean square error, direct analytic solution. This component also computes the centroid of the contour.",
      "fields": [
        {
          "field": "linregc1",
          "description": "1/0=enable/disable output of slope m (linear regression line)",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "linregc2",
          "description": "1/0=enable/disable output of offset t (linear regression line)",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "linregerrA",
          "description": "1/0=enable/disable output of linear error between contour and linear regression line",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "linregerrQ",
          "description": "1/0=enable/disable output of quadratic error between contour and linear regression line",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "qregc1",
          "description": "1/0=enable/disable output of quadratic regression coefficient 1 (a)",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "qregc2",
          "description": "1/0=enable/disable output of quadratic regression coefficient 2 (b)",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "qregc3",
          "description": "1/0=enable/disable output of quadratic regression coefficient 3 (c = offset)",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "qregerrA",
          "description": "1/0=enable/disable output of linear error between contour and quadratic regression line (parabola)",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "qregerrQ",
          "description": "1/0=enable/disable output of quadratic error between contour and quadratic regression line (parabola)",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "centroid",
          "description": "1/0=enable/disable output of centroid of contour (this is computed as a by-product of the regression coefficients).",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "centroidNorm",
          "description": "normalise time-scale of centroid to time in seconds (seconds), frame index (frame), or relative segment percentage (segment).",
          "type": "string",
          "default": "segment",
          "allowedValues": [
            "seconds",
            "frame",
            "segment"
          ]
        },
        {
          "field": "centroidUseAbsValues",
          "description": "1/0=enable/disable. Use absolute values when computing temporal centroid. Default in pre 2.2 versions was 0. In 2.2 the default changes to 1!",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "centroidRatioLimit",
          "description": "(1/0) = yes/no. Apply soft limiting of centroid to valid (segment range) in order to avoid high uncontrolled output values if the denominator (absolute mean of values) is close to 0. For strict compatibility with pre 2.2 openSMILE releases (also release candidates 2.2rc1), set it to 0. Default in new versions is 1 (enabled).",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "qregls",
          "description": "1/0=enable/disable output of left slope of parabola (slope of the line from first point on the parabola at t=0 to the vertex).",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "qregrs",
          "description": "1/0=enable/disable output of right slope of parabola (slope of the line from the vertex to the last point on the parabola at t=N).",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "qregx0",
          "description": "1/0=enable/disable output of x coordinate of the parabola vertex (since for very flat parabolas this can be very large/small, it is clipped to range -Nin - +Nin ).",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "qregy0",
          "description": "1/0=enable/disable output of y coordinate of the parabola vertex.",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "qregyr",
          "description": "1/0=enable/disable output of y coordinate of the last point on the parabola (t=N).",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "qregy0nn",
          "description": "1/0=enable/disable output of y coordinate of the parabola vertex. This value is unnormalised, regardless of value of normInput.",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "qregc3nn",
          "description": "1/0=enable/disable output of y coordinate of the first point on the parabola (t=0). This value is unnormalised, regardless of value of normInput.",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "qregyrnn",
          "description": "1/0=enable/disable output of y coordinate of the last point on the parabola (t=N). This value is unnormalised, regardless of value of normInput.",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "normRegCoeff",
          "description": "If > 0, do normalisation of regression coefficients, slopes, and coordinates on the time scale.\n  If == 1 (segment relative scaling), the coefficients are scaled (multiplied by the contour length) so that a regression line or parabola approximating the contour can be plotted over an x-axis range from 0 to 1, i.e. this makes the coefficients independent of the contour length (a longer contour with a lower slope will then have the same 'm' (slope) linear regression coefficient as a shorter but steeper slope).\n  If == 2, normalisation of time scale to the units of seconds, i.e. slope is value_delta/second.\n  Note: The unnormalised slope is value_delta/timestep.",
          "type": "numeric",
          "default": 0.0
        },
        {
          "field": "normInputs",
          "description": "1/0=enable/disable normalisation of regression coefficients, coordinates, and regression errors on the value scale. If enabled all input values will be normalised to the range 0..1. Use this in conjunction with normRegCoeff.",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "oldBuggyQerr",
          "description": "Set this to 1 (default) to output the (input lengthwise) unnormalised quadratic regression errors (if qregerr* == 1) for compatibility with older feature sets. In new setups you should always change from the default to 0 to enable the proper scaling of the quadratic error!",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ],
          "recommendedValue": 0.0
        },
        {
          "field": "doRatioLimit",
          "description": "(1/0) = yes/no. Apply soft limiting of ratio features (slopes etc.) in order to avoid high uncontrolled output values if the denominator is close to 0. For strict compatibility with pre 2.2 openSMILE releases (also release candidates 2.2rc1), set it to 0 (current default)",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        }
      ]
    },
    {
      "component": "cFunctionalSamples",
      "description": "sampled values at equidistant frames",
      "fields": [
        {
          "field": "samplepos",
          "description": "Array of positions of samples to copy to the output. The size of this array determines the number of sample frames that will be passed to the output. The given positions must be in the range from 0 to 1, indicating the relative position whithin the input segment, where 0 is the beginning and 1 the end of the segment.",
          "type": "numeric",
          "default": 0.0
        }
      ]
    },
    {
      "component": "cFunctionalTimes",
      "description": "up- and down-level times + rise and fall, left- and right-curve times, duration, etc.",
      "fields": [
        {
          "field": "upleveltime25",
          "description": "(1/0=yes/no) compute time where signal is above 0.25*range",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "downleveltime25",
          "description": "(1/0=yes/no) compute time where signal is below 0.25*range",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "upleveltime50",
          "description": "(1/0=yes/no) compute time where signal is above 0.50*range",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "downleveltime50",
          "description": "(1/0=yes/no) compute time where signal is below 0.50*range",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "upleveltime75",
          "description": "(1/0=yes/no) compute time where signal is above 0.75*range",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "downleveltime75",
          "description": "(1/0=yes/no) compute time where signal is below 0.75*range",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "upleveltime90",
          "description": "(1/0=yes/no) compute time where signal is above 0.90*range",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "downleveltime90",
          "description": "(1/0=yes/no) compute time where signal is below 0.90*range",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "risetime",
          "description": "(1/0=yes/no) compute time where signal is rising",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "falltime",
          "description": "(1/0=yes/no) compute time where signal is falling",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "leftctime",
          "description": "(1/0=yes/no) compute time where signal has left curvature",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "rightctime",
          "description": "(1/0=yes/no) compute time where signal has right curvature",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "duration",
          "description": "(1/0=yes/no) compute duration time, in frames (or seconds, if (time)norm==seconds)",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "upleveltime",
          "description": "compute time where signal is above X*range : upleveltime[n]=X",
          "type": "numeric",
          "default": 0.9
        },
        {
          "field": "downleveltime",
          "description": "compute time where signal is below X*range : downleveltime[n]=X",
          "type": "numeric",
          "default": 0.9
        },
        {
          "field": "norm",
          "description": "This option specifies how this component should normalise times (if it generates output values related to durations): \n   'segment' (or: 'turn') : normalise to the range 0..1, the result is the relative length wrt. to the segment length )\n   'second'  (absolute time in seconds) \n   'frame' (absolute time in number of frames of input level)",
          "type": "string",
          "default": "segment",
          "allowedValues": [
            "segment",
            "segments",
            "turn",
            "turns",
            "second",
            "seconds",
            "frame",
            "frames"
          ],
          "suggestedValues": [
            "segment",
            "turn",
            "second",
            "frame"
          ]
        },
        {
          "field": "buggySecNorm",
          "description": "If set to 1, enables the old (prior to version 1.0.0 , 07 May 2010) second normalisation code which erroneously divides by the number of input frames. The default is kept at 1 (enabled) in order to not break compatibility with old configuration files, however you are strongly encouraged to change this to 0 in any new configuration you write in order to get the times in actual (bug-free) seconds!",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ],
          "recommendedValue": 0.0
        },
        {
          "field": "useRobustPercentileRange",
          "description": "Estimate range based on low/high percentiles (set by the pctlRangeMargin option) instead of single max/min values.",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "pctlRangeMargin",
          "description": "Minimum percentile (and 1-x for maximum percentile) for range estimation with option useRobustPercentileRange. Valid range between > 0 and < 0.5, recommended: 0.02-0.10",
          "type": "numeric",
          "default": 0.05
        }
      ]
    },
    {
      "component": "cFunctionalDCT",
      "description": "DCT coefficients",
      "fields": [
        {
          "field": "firstCoeff",
          "description": "The first DCT coefficient to compute (coefficient 0 corresponds to the DC component)",
          "type": "numeric",
          "default": 1.0
        },
        {
          "field": "lastCoeff",
          "description": "The last DCT coefficient to compute",
          "type": "numeric",
          "default": 6.0
        },
        {
          "field": "nCoeffs",
          "description": "An alternative option to lastCoeff (this option overwrites lastCoeff, if it is set): the number DCT coefficient to compute (lastCoeff = firstCoeff+nCoeffs-1).",
          "type": "numeric",
          "default": 6.0
        }
      ]
    },
    {
      "component": "cFunctionalLpc",
      "description": "LP coefficients as functionals",
      "fields": [
        {
          "field": "lpGain",
          "description": "Output of LP gain (1=yes / 0=no).",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "lpc",
          "description": "Output of LP coefficients (1=yes / 0=no).",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "firstCoeff",
          "description": "The first LP coefficient to compute. The first coefficient is coeff 0 (default)",
          "type": "numeric",
          "default": 0.0
        },
        {
          "field": "order",
          "description": "The order of the linear prediction (i.e. the max number of coefficients, starting at coefficient number 0).",
          "type": "numeric",
          "default": 5.0
        }
      ]
    },
    {
      "component": "cPortaudioWavplayer",
      "description": "This component can play wavefiles directly to a portaudio output device. Multiple wave files can be specified as inputs and they can be played via smile messages containing the index of the sample to play. Concurrent play requests will be discarded (TODO: mix the output). All wave files must have the same sampling rate.",
      "fields": [
        {
          "field": "monoMixdown",
          "description": "mix down all channels to 1 mono channel",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "device",
          "description": "PortAudio device to use (device number)",
          "type": "numeric",
          "default": -1.0
        },
        {
          "field": "listDevices",
          "description": "(1/0=yes/no) list available portaudio devices during initialisation phase",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "sampleRate",
          "description": "force output sample rate (0=determine sample rate from input level)",
          "type": "numeric",
          "default": 0.0
        },
        {
          "field": "wavefile",
          "description": "The filenames of the wavesample(s) to play (triggered via smile message or numbers read from the input level).",
          "type": "string",
          "default": null
        },
        {
          "field": "keyword",
          "description": "List of keywords or classnames (in same order as wave files)",
          "type": "string",
          "default": null
        },
        {
          "field": "indices",
          "description": "List of class indicies for classification results (same order as wave files)",
          "type": "numeric",
          "default": -1.0
        },
        {
          "field": "semaineCallbackRcpt",
          "description": "Reciepient of SEMAINE callback message for echo feedback supression (start speaking / stop speaking messages, i.e. when player starts playing/stops playing).",
          "type": "string",
          "default": null,
          "typeHint": "componentInstance"
        },
        {
          "field": "audioBuffersize",
          "description": "size of port audio playback buffer in samples (overwrites audioBuffersize_sec, if set)",
          "type": "numeric",
          "default": 1000.0
        }
      ]
    },
    {
      "component": "cPortaudioSource",
      "description": "This component handles live audio recording from the soundcard via the PortAudio library",
      "writesToLevels": [
        "writer.dmLevel"
      ],
      "baseComponent": "cDataSource",
      "fields": [
        {
          "field": "period",
          "description": "(optional) The period of the input frames (in seconds), if it cannot be determined from the input file format. (if set and != 0, this will overwrite any automatically set values, e.g. from samplerate and writer.levelconf etc. (NOTE: this behaviour also depends on the source component, whether it overwrites period in configureWriter() or whether it keeps the period if it is != 0.0))",
          "type": "numeric",
          "default": 0.0
        },
        {
          "field": "monoMixdown",
          "description": "Mix down all recorded channels to 1 mono channel",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "device",
          "description": "PortAudio device to use (device number, see the option 'listDevices' to get information on device numbers)",
          "type": "numeric",
          "default": -1.0
        },
        {
          "field": "listDevices",
          "description": "If set to 1, openSMILE will list available portaudio devices during initialisation phase and exit immediately after that (you might get an error message on windows, which you can ignore).",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "sampleRate",
          "description": "The sampling rate to use for audio recording (if supported by device!)",
          "type": "numeric",
          "default": 16000.0
        },
        {
          "field": "channels",
          "description": "The number of channels to record (check your device's capabilities!",
          "type": "numeric",
          "default": 1.0
        },
        {
          "field": "selectChannel",
          "description": "Select only the specified channel from 'channels' that are recorded. Set to -1 to grab all channels.",
          "type": "numeric",
          "default": -1.0
        },
        {
          "field": "nBits",
          "description": "The number of bits per sample and channel",
          "type": "numeric",
          "default": 16.0
        },
        {
          "field": "nBPS",
          "description": "The number of bytes per sample and channel (0=determine automatically from nBits)",
          "type": "numeric",
          "default": 0.0
        },
        {
          "field": "audioBuffersize",
          "description": "The size of the portaudio recording buffer in samples (overwrites audioBuffersize_sec, if set)",
          "type": "numeric",
          "default": 0.0
        },
        {
          "field": "audioBuffersize_sec",
          "description": "size of the portaudio recording buffer in seconds. This value has influence on the system latency. Setting it too high might introduce a high latency. A too low value might lead to dropped samples and reduced performance.",
          "type": "numeric",
          "default": 0.05
        },
        {
          "field": "byteSwap",
          "description": "1 = swap bytes, big endian <-> little endian (usually not required)",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        }
      ]
    },
    {
      "component": "cPortaudioSink",
      "description": "This component handles live audio playback via the PortAudio library",
      "readsFromLevels": [
        "reader.dmLevel"
      ],
      "baseComponent": "cDataSink",
      "fields": [
        {
          "field": "monoMixdown",
          "description": "mix down all channels to 1 mono channel",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "device",
          "description": "PortAudio device to use (device number)",
          "type": "numeric",
          "default": -1.0
        },
        {
          "field": "listDevices",
          "description": "(1/0=yes/no) list available portaudio devices during initialisation phase",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "sampleRate",
          "description": "force output sample rate (0=determine sample rate from input level)",
          "type": "numeric",
          "default": 0.0
        },
        {
          "field": "audioBuffersize",
          "description": "size of port audio recording buffer in samples (overwrites audioBuffersize_sec, if set)",
          "type": "numeric",
          "default": 1000.0
        },
        {
          "field": "audioBuffersize_sec",
          "description": "size of port audio recording buffer in seconds",
          "type": "numeric",
          "default": 0.05
        }
      ]
    },
    {
      "component": "cPortaudioDuplex",
      "description": "dataProcessor for full-duplex playback and recording of live audio using PortAudio library",
      "readsFromLevels": [
        "reader.dmLevel"
      ],
      "writesToLevels": [
        "writer.dmLevel"
      ],
      "baseComponent": "cDataProcessor",
      "fields": [
        {
          "field": "monoMixdownPB",
          "description": "mix down all channels to 1 mono channel (for playback)",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "monoMixdownREC",
          "description": "mix down all channels to 1 mono channel (for recording)",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "device",
          "description": "PortAudio device to use (device number)",
          "type": "numeric",
          "default": -1.0
        },
        {
          "field": "listDevices",
          "description": "(1/0=yes/no) list available portaudio devices during initialisation phase",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "sampleRate",
          "description": "recording AND playback sample rate (WARNING: no sample rate conversion of input level data will be performed prior to playback!)",
          "type": "numeric",
          "default": 44100.0
        },
        {
          "field": "nBits",
          "description": "number of bits per sample and channel to use for playback (0=pass float values to portaudio)  [ NOT IMPLEMENTED YET ]",
          "type": "numeric",
          "default": 0.0
        },
        {
          "field": "channels",
          "description": "number of channels to record",
          "type": "numeric",
          "default": 1.0
        },
        {
          "field": "audioBuffersize",
          "description": "size of port audio playback&recording buffer in samples",
          "type": "numeric",
          "default": 1000.0
        },
        {
          "field": "audioBuffersize_sec",
          "description": "size of port audio playback&recording buffer in seconds",
          "type": "numeric",
          "default": 0.05
        }
      ]
    },
    {
      "component": "cJuliusSink",
      "description": "keyword spotter using Julius decoder",
      "baseComponent": "cDataSink",
      "readsFromLevels": [
        "reader.dmLevel"
      ],
      "sendsMessagesToComponents": [
        "juliusResultRecp",
        "kwsResultRecp"
      ],
      "fields": [
        {
          "field": "configfile",
          "type": "string",
          "description": "Julius configfile to load (path is relative to smile executable)",
          "default": "kws.cfg"
        },
        {
          "field": "logfile",
          "type": "string",
          "description": "Julius logfile (default=(null) : no log file)",
          "default": null
        },
        {
          "field": "debug",
          "type": "numeric",
          "description": "1 = show julius debug log output, 0 = don't show",
          "default": 0,
          "allowedValues": [
            0,
            1
          ]
        },
        {
          "field": "preSil",
          "type": "numeric",
          "description": "extra (silence) amount of data at beginning of turn to keep (in seconds)",
          "default": 0.3
        },
        {
          "field": "postSil",
          "type": "numeric",
          "description": "extra (silence) amount of data at end of turn to keep (in seconds)",
          "default": 0.4
        },
        {
          "field": "nopass2",
          "type": "numeric",
          "description": "1 = do not perform pass2 (you must also set the '-1pass' option in the julius config file!)",
          "default": 0,
          "allowedValues": [
            0,
            1
          ]
        },
        {
          "field": "printResult",
          "type": "numeric",
          "description": "print output packages to console (1/0=yes/no)",
          "default": 1,
          "allowedValues": [
            0,
            1
          ]
        },
        {
          "field": "juliusResultRecp",
          "type": "string",
          "typeHint": "componentInstance",
          "description": "component(s) to send 'juliusResult' messages to (use , to separate multiple recepients), leave blank (NULL) to not send any messages. The 'juliusResult' message contains the full julius result package, which includes the full word string, alignments (if available) and the word scores as well as am and lm scores.",
          "default": null
        },
        {
          "field": "kwsResultRecp",
          "type": "string",
          "typeHint": "componentInstance",
          "description": "component(s) to send 'asrKeywordOutput' messages to (use , to separate multiple recepients), leave blank (NULL) to not send any messages. The keyword result package only contains selected keywords (given in 'keywordList') from the full julius result package.",
          "default": null
        },
        {
          "field": "keywordList",
          "type": "string",
          "description": "name of text file to load keyword list from. The file must contain the keywords (all uppercase) sorted in alphabetical order, each keyword on a line.",
          "default": null
        },
        {
          "field": "excludeWords",
          "type": "string",
          "description": "array of strings (words) to exclude from result packages. Typically you would use this to exclude sentence start and end marks such as <s> or </s>. The default is an empty list, i.e. nothing will be excluded.",
          "default": null
        },
        {
          "field": "noTurns",
          "type": "numeric",
          "description": "1 = don't use turn segmentation info, simply pass all available input data to julius (you can either do VAD with julius then, or use this feature in offline mode when you use presegmented turns) (0 = segment input based on cTurnDetector messages).",
          "default": 0,
          "allowedValues": [
            0,
            1
          ]
        },
        {
          "field": "offlineMode",
          "type": "numeric",
          "description": "1 = off-line evaluation mode (this changes the exit behaviour of the decoder; in online mode the decoder will always return 1 (busy) when decoding; in off-line mode it will return 0 if it is processing if not in the EOI processing loop. This option will also set maxTurnQue=0 (infinite).",
          "default": 0,
          "allowedValues": [
            0,
            1
          ]
        },
        {
          "field": "maxTurnQue",
          "type": "numeric",
          "description": "maximum number of speech turns to hold in que, set this to 0 (infinite) for offline evaluations, and 2 (or more) for online mode",
          "default": 2,
          "allowedValues": [
            0,
            1,
            2
          ]
        },
        {
          "field": "decoderThreadPriority",
          "type": "numeric",
          "description": "the thread priority of the decoder thread (currently only supported on windows), values -15 (idle) to 15 (real-time), while 0 is normal. This should be lower as or equal to the priority of the openSMILE main thread!",
          "default": 0
        }
      ]
    },
    {
      "component": "cOpenslesSource",
      "description": "This component reads opensl audio buffer input into datamemory.",
      "baseComponent": "cDataSource",
      "writesToLevels": [
        "writer.dmLevel"
      ],
      "fields": [
        {
          "field": "monoMixdown",
          "type": "numeric",
          "description": "Mix down all channels to 1 mono channel (1=on, 0=off)",
          "default": 1,
          "allowedValues": [
            0,
            1
          ]
        },
        {
          "field": "sampleRate",
          "type": "numeric",
          "description": "Set/force the sampling rate that is assigned to the input data.",
          "default": 16000
        },
        {
          "field": "channels",
          "type": "numeric",
          "description": "Set/force the number of input (recording) channels",
          "default": 1
        },
        {
          "field": "outFieldName",
          "type": "string",
          "description": "Set the name of the output field, containing the pcm data",
          "default": "pcm"
        },
        {
          "field": "nBits",
          "type": "numeric",
          "description": "The number of bits per sample and channel",
          "default": 16
        },
        {
          "field": "nBPS",
          "type": "numeric",
          "description": "The number of bytes per sample and channel (0=determine automatically from nBits)",
          "default": 0
        },
        {
          "field": "audioBuffersize",
          "type": "numeric",
          "description": "The size of the portaudio recording buffer in samples (overwrites audioBuffersize_sec, if set)",
          "default": 0
        },
        {
          "field": "audioBuffersize_sec",
          "type": "numeric",
          "description": "size of the portaudio recording buffer in seconds. This value has influence on the system latency. Setting it too high might introduce a high latency. A too low value might lead to dropped samples and reduced performance.",
          "default": 0.05
        },
        {
          "field": "agcEnabled",
          "type": "numeric",
          "description": "1/0 = enable automatic gain control for input audio",
          "default": 0,
          "allowedValues": [
            0,
            1
          ]
        },
        {
          "field": "agcTarget",
          "type": "numeric",
          "description": "Target peak level for AGC, if enabled.",
          "default": 0.5
        },
        {
          "field": "agcDebug",
          "type": "numeric",
          "description": "1/0 = enable agc debugging output to log.",
          "default": 0,
          "allowedValues": [
            0,
            1
          ]
        }
      ]
    },
    {
      "component": "cJniMessageInterface",
      "description": "Component for transferring smile component messages from native C to Java via JNI interface.",
      "fields": [
        {
          "field": "sendMessagesInTick",
          "type": "numeric",
          "description": "1/0 enable/disable sending of messages synchronized in tick(). If set to 0, a background thread will be started which will send messages from the queue in the background (NOT YET IMPLEMENTED).",
          "default": 1,
          "allowedValues": [
            0,
            1
          ]
        },
        {
          "field": "JNIcallbackClass",
          "type": "string",
          "description": "Fully qualified Java name of class in APP which handles callbacks. Must be changed to the app namespace and domain.",
          "default": "java/com/audeering/testapp01/SmileJNIcallbacks"
        },
        {
          "field": "JNIstringReceiverMethod",
          "type": "string",
          "description": "Name of method which receives string messages in JNIcallbackClass. Default should not need to be changed, if class wasn't changed.",
          "default": "receiveText"
        },
        {
          "field": "debugPrintJson",
          "type": "numeric",
          "description": "1 = debug print to smile log the formatted json before sending.",
          "default": 0,
          "allowedValues": [
            0,
            1
          ]
        }
      ]
    },
    {
      "component": "cOpenCVSource",
      "description": "Captures frames from either webcam or file stream, extracts a square region containing the face and creates a LBP, HSV and optical flow histogram.",
      "baseComponent": "cDataSource",
      "writesToLevels": [
        "writer.dmLevel"
      ],
      "fields": [
        {
          "field": "display",
          "type": "numeric",
          "description": "Show original and extracted video",
          "default": 1,
          "allowedValues": [
            0,
            1
          ]
        },
        {
          "field": "videoSource",
          "type": "string",
          "description": "Choose Video Source: WEBCAM or FILE",
          "default": "WEBCAM"
        },
        {
          "field": "filename",
          "type": "string",
          "description": "Filename of video, if VideoSource = FILE",
          "default": ""
        },
        {
          "field": "fps",
          "type": "numeric",
          "description": "Frames per second",
          "default": 30.0
        },
        {
          "field": "face_cascade_path",
          "type": "string",
          "description": "Path to OpenCV face cascade xml file",
          "default": "/usr/share/opencv/data/lbpcascades/lbpcascade_frontalface.xml"
        },
        {
          "field": "eyes_cascade_path",
          "type": "string",
          "description": "Path to OpenCV eyes cascade xml file",
          "default": "/usr/share/opencv/data/haarcascades/haarcascade_eye_tree_eyeglasses.xml"
        },
        {
          "field": "extract_face",
          "type": "numeric",
          "description": "Extract face and eyes?",
          "default": 1,
          "allowedValues": [
            0,
            1
          ]
        },
        {
          "field": "extract_hsv_histogram",
          "type": "numeric",
          "description": "Extract HSV histogram?",
          "default": 1,
          "allowedValues": [
            0,
            1
          ]
        },
        {
          "field": "extract_lbp_histogram",
          "type": "numeric",
          "description": "Extract LBP histogram?",
          "default": 1,
          "allowedValues": [
            0,
            1
          ]
        },
        {
          "field": "extract_optical_flow",
          "type": "numeric",
          "description": "Extract optical flow histogram?",
          "default": 1,
          "allowedValues": [
            0,
            1
          ]
        },
        {
          "field": "include_face_features",
          "type": "numeric",
          "description": "Include face features (eye position + distance etc.) in feature vector?",
          "default": 0,
          "allowedValues": [
            0,
            1
          ]
        },
        {
          "field": "ignore_invalid_frames",
          "type": "numeric",
          "description": "Ignore invalid frames (e.g. when no face is detected. Cave: Might lead to synchronisation errors.",
          "default": 1,
          "allowedValues": [
            0,
            1
          ]
        },
        {
          "field": "face_width",
          "type": "numeric",
          "description": "Width/height of extracted face square",
          "default": 60
        },
        {
          "field": "lbp_uniformpatterns",
          "type": "numeric",
          "description": "Use uniform patterns for LBP histogram",
          "default": 0,
          "allowedValues": [
            0,
            1
          ]
        },
        {
          "field": "hsv_histogram_h_bins",
          "type": "numeric",
          "description": "HSV histogram: Hue bins",
          "default": 50
        },
        {
          "field": "hsv_histogram_s_bins",
          "type": "numeric",
          "description": "HSV histogram: Saturation bins",
          "default": 50
        },
        {
          "field": "hsv_histogram_v_bins",
          "type": "numeric",
          "description": "HSV histogram: Value bins",
          "default": 50
        },
        {
          "field": "of_histogram_bins",
          "type": "numeric",
          "description": "Optical flow histogram: Bins",
          "default": 10
        },
        {
          "field": "normalize_histograms",
          "type": "numeric",
          "description": "Normalize histograms (L1-norm)",
          "default": 0,
          "allowedValues": [
            0,
            1
          ]
        },
        {
          "field": "of_histogram_max_flow",
          "type": "numeric",
          "description": "Optical flow histogram: Max flow",
          "default": 0.2
        },
        {
          "field": "of_histogram_downsample",
          "type": "numeric",
          "description": "Optical flow histogram: Downsample",
          "default": 0.3
        },
        {
          "field": "use_lbpc",
          "type": "numeric",
          "description": "Use LBP-C (circular LBP)",
          "default": 0,
          "allowedValues": [
            0,
            1
          ]
        },
        {
          "field": "lbpc_radius",
          "type": "numeric",
          "description": "LBP-C radius",
          "default": 1
        },
        {
          "field": "lbpc_points",
          "type": "numeric",
          "description": "LBP-C points (currently only 8 points supported)",
          "default": 8
        }
      ]
    },
    {
      "component": "cVectorBinaryOperation",
      "description": "This component performs element-wise binary operations on vectors (+, -, *, /, ^, min, max). Requires both fields to have the same dimensions.",
      "readsFromLevels": [
        "reader.dmLevel"
      ],
      "writesToLevels": [
        "writer.dmLevel"
      ],
      "baseComponent": "cDataProcessor",
      "fields": [
        {
          "field": "fieldNames",
          "description": "An array of exact (case-sensitive) names of features / data elements to process (for subtraction, division and power, there must be exactly two fields). All the data vectors must have the same dimension.",
          "type": "string",
          "default": null
        },
        {
          "field": "operation",
          "description": "A string which specifies the type of element-wise operation to perform:\n   add = add vectors\n   sub = subtract vector 2 to vector 1 (in the order given by the 'fieldNames' parameter), 0\n   mul = multiply vectors \n   div = divide vector 1 by vector 2, 0\n   pow = take values of vector 1 to the power of values of vector 2\n   min = take the min\n   max = take the max.",
          "type": "string",
          "default": "add",
          "allowedValues": [
            "add",
            "sub",
            "mul",
            "div",
            "pow",
            "min",
            "max"
          ]
        },
        {
          "field": "newName",
          "description": "New name to assign to the resulting features / data elements (optional).",
          "type": "string",
          "default": null
        },
        {
          "field": "powOnlyPos",
          "description": "if 'operation' = 'pow', do not take negative values to the power of 'param1'; instead, output 0. This is necessary to avoid 'nan' values if the exponent is rational.",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "dummyMode",
          "description": "1 = don't set up output level names. Use this option temporarily, to get a working set-up where you can read the input level names, to set up your selection list.",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "divZeroOutputVal1",
          "description": "1 = In case of 'div' operation, output value1 in case of value2 == 0 (= division by zero). 0 = output 0 when division by zero.",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        }
      ]
    },
    {
      "component": "cExternalMessageInterface",
      "description": "This component forwards component messages to external code via callbacks.",
      "fields": []
    },
    {
      "component": "cExternalSink",
      "description": "This component allows external code to programmatically access the data read by this component.",
      "readsFromLevels": [
        "reader.dmLevel"
      ],
      "baseComponent": "cDataSink",
      "fields": []
    },
    {
      "component": "cExternalSource",
      "description": "This component reads data that is passed to the component programmatically.",
      "writesToLevels": [
        "writer.dmLevel"
      ],
      "baseComponent": "cDataSource",
      "fields": [
        {
          "field": "blocksize",
          "description": "The maximum size of data buffers that can be passed to this component at once in samples (overwrites blocksize_sec, if set)",
          "type": "numeric",
          "default": 0.0
        },
        {
          "field": "blocksize_sec",
          "description": "The maximum size of data buffers that can be passed to this component at once in seconds.",
          "type": "numeric",
          "default": 0.05
        },
        {
          "field": "period",
          "description": "(optional) The period of the input frames (in seconds), if it cannot be determined from the input file format. (if set and != 0, this will overwrite any automatically set values, e.g. from samplerate and writer.levelconf etc. (NOTE: this behaviour also depends on the source component, whether it overwrites period in configureWriter() or whether it keeps the period if it is != 0.0))",
          "type": "numeric",
          "default": 0.0
        },
        {
          "field": "fieldNames",
          "description": "Name of dataMemory fields, array.",
          "type": "string",
          "default": null
        },
        {
          "field": "fieldSizes",
          "description": "dataMemory field sizes, array. Order must match fieldNames. Default is 1 if this array is not given. If you specify a field size for one field, you must specify it for all.",
          "type": "numeric",
          "default": 1.0
        }
      ]
    },
    {
      "component": "cExternalAudioSource",
      "description": "This component reads audio input that is passed to the component programmatically.",
      "writesToLevels": [
        "writer.dmLevel"
      ],
      "baseComponent": "cDataSource",
      "fields": [
        {
          "field": "blocksize",
          "description": "The maximum size of audio sample buffers that can be passed to this component at once in samples (per channel, overwrites blocksize_sec, if set)",
          "type": "numeric",
          "default": 0.0
        },
        {
          "field": "blocksize_sec",
          "description": "The maximum size of sample buffers that can be passed to this component at once in seconds.",
          "type": "numeric",
          "default": 0.05
        },
        {
          "field": "period",
          "description": "(optional) The period of the input frames (in seconds), if it cannot be determined from the input file format. (if set and != 0, this will overwrite any automatically set values, e.g. from samplerate and writer.levelconf etc. (NOTE: this behaviour also depends on the source component, whether it overwrites period in configureWriter() or whether it keeps the period if it is != 0.0))",
          "type": "numeric",
          "default": 0.0
        },
        {
          "field": "sampleRate",
          "description": "The sampling rate of the external audio input",
          "type": "numeric",
          "default": 16000.0
        },
        {
          "field": "channels",
          "description": "The number of channels of the external audio input",
          "type": "numeric",
          "default": 1.0
        },
        {
          "field": "nBits",
          "description": "The number of bits per sample and channel of the external audio input",
          "type": "numeric",
          "default": 16.0
        },
        {
          "field": "nBPS",
          "description": "The number of bytes per sample and channel of the external audio input (0=determine automatically from nBits)",
          "type": "numeric",
          "default": 0.0
        },
        {
          "field": "fieldName",
          "description": "Name of dataMemory field data is written to.",
          "type": "string",
          "default": "pcm"
        }
      ]
    },
    {
      "component": "cDataPrintSink",
      "description": "This component prints data as text to stdout or log, optionally in a standard parseable result format.",
      "readsFromLevels": [
        "reader.dmLevel"
      ],
      "baseComponent": "cDataSink",
      "fields": [
        {
          "field": "parseable",
          "description": "1 = Print parseable output to stdout. 0 = Print human readable output to stdout or log (depending on the value of useLog).",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "useLog",
          "description": "1 = Use the log for human readable output. 0 = use stdout.",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "printTimeMeta",
          "description": "1 = Include TimeMetaInfo (tmeta) in the output. 0 = do not include TimeMetaInfo.",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        }
      ]
    },
    {
      "component": "cFFmpegSource",
      "description": "This component uses FFmpeg to decode audio from media files.",
      "writesToLevels": [
        "writer.dmLevel"
      ],
      "baseComponent": "cDataSource",
      "fields": [
        {
          "field": "blocksize_sec",
          "description": "The size of data blocks to write at once, in seconds",
          "type": "numeric",
          "default": 1.0
        },
        {
          "field": "filename",
          "description": "The filename of the media file to load. The file must contain an audio stream decodable by FFmpeg.",
          "type": "string",
          "default": "input.wav",
          "required": true
        },
        {
          "field": "monoMixdown",
          "description": "Mix down all channels to 1 mono channel (1=on, 0=off)",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "outFieldName",
          "description": "Set the name of the output field, containing the pcm data",
          "type": "string",
          "default": "pcm"
        }
      ]
    },
    {
      "component": "cFunctionalModulation",
      "description": "Modulation Spectrum",
      "fields": [
        {
          "field": "stftWinSizeSec",
          "description": "Window size of Short Time Fourier Transformation in seconds. Set to 0 to use (zero-padded to next power of 2) full input segment. If the input is smaller than 'stftWinSizeSec', it will be zero padded to 'stftWinSizeSec'. Segments will further be zero padded to the next higher power of 2 (in frames).",
          "type": "numeric",
          "default": 4.0
        },
        {
          "field": "stftWinStepSec",
          "description": "Step size of Short Time Fourier Transformation in seconds. Default 0.0 will set the step size to the same as the window size.",
          "type": "numeric",
          "default": 0.0
        },
        {
          "field": "stftWinSizeFrames",
          "description": "Window size of Short Time Fourier Transformation in input frames. Set to 0 to use (zero-padded to next power of 2) full input segment. If the input is smaller than 'stftWinSizeSec', it will be zero padded to 'stftWinSizeSec'. Segments will further be zero padded to the next higher power of 2. If this option is set, it overrides stftWinSizeSec.",
          "type": "numeric",
          "default": 400.0
        },
        {
          "field": "stftWinStepFrames",
          "description": "Window size of Short Time Fourier Transformation in input frames. Default 0 will set the step size to the same as the window size.",
          "type": "numeric",
          "default": 0.0
        },
        {
          "field": "fftWinFunc",
          "description": "STFT window function.",
          "type": "string",
          "default": "ham",
          "allowedValues": [
            "Han",
            "han",
            "Hanning",
            "hanning",
            "hann",
            "Hann",
            "Ham",
            "ham",
            "Hamming",
            "hamming",
            "Rec",
            "rec",
            "Rectangular",
            "rectangular",
            "none",
            "None",
            "Gau",
            "gau",
            "Gauss",
            "gauss",
            "Gaussian",
            "gaussian",
            "Sin",
            "sin",
            "Sine",
            "sine",
            "cosine",
            "Cosine",
            "Cos",
            "cos",
            "Tri",
            "tri",
            "Triangle",
            "triangle",
            "Bar",
            "bar",
            "Bartlett",
            "bartlett",
            "BaH",
            "bah",
            "Bartlett-Hann",
            "bartlett-hann",
            "Bartlett-Hanning",
            "bartlett-hanning",
            "Bla",
            "bla",
            "Blackman",
            "blackman",
            "BlH",
            "blh",
            "Blackman-Harris",
            "blackman-harris",
            "Lac",
            "lac",
            "Lanczos",
            "lanczos"
          ],
          "suggestedValues": [
            "Han",
            "Ham",
            "Rec",
            "Gau",
            "Sin",
            "Tri",
            "Bar",
            "BaH",
            "Bla",
            "BlH",
            "Lac"
          ]
        },
        {
          "field": "modSpecResolution",
          "description": "Output resolution (in Hz) of modulation spectrum (interpolated from stft). This is preferred over num bins, but if num bins is set, it will override this option.",
          "type": "numeric",
          "default": 0.5
        },
        {
          "field": "modSpecNumBins",
          "description": "Alternative to specifying the resolution, specifies the number of bins. Overrides 'modSpecResolution', if set.",
          "type": "numeric",
          "default": 50.0
        },
        {
          "field": "modSpecMinFreq",
          "description": "Lower bound of modulation spectrum (in Hz).",
          "type": "numeric",
          "default": 0.5
        },
        {
          "field": "modSpecMaxFreq",
          "description": "Upper bound of modulation spectrum (in Hz).",
          "type": "numeric",
          "default": 20.0
        },
        {
          "field": "showModSpecScale",
          "description": "(1/0 = yes/no) Print the frequency axis of the modulation spectrum during initialisation.",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "removeNonZeroMean",
          "description": "(1/0 = yes/no) Remove the mean of all non-zero values (use for F0 modulation spectrum for example).",
          "type": "numeric",
          "default": 0.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        },
        {
          "field": "ignoreLastFrameIfTooShort",
          "description": "(1/0 = yes/no) If stftWinSize is not 0 (i.e. not using full input length), ignore the last window if it is smaller than 2/3 of stftWinSize.",
          "type": "numeric",
          "default": 1.0,
          "allowedValues": [
            0.0,
            1.0
          ]
        }
      ]
    }
  ]
}